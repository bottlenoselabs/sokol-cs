
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/bottlenoselabs/c2cs (v2.3.1.0)
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------
#nullable enable
#pragma warning disable 1591
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using static bottlenoselabs.sokol.Runtime;

namespace bottlenoselabs
{
    public static unsafe partial class sokol
    {
        private const string LibraryName = "sokol";

        // Function @ sokol_app.h:1431:18
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sapp_desc sokol_main(int argc, CString* argv);

        // Function @ sokol_app.h:1434:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sapp_isvalid();

        // Function @ sokol_app.h:1436:24
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int sapp_width();

        // Function @ sokol_app.h:1438:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern float sapp_widthf();

        // Function @ sokol_app.h:1440:24
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int sapp_height();

        // Function @ sokol_app.h:1442:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern float sapp_heightf();

        // Function @ sokol_app.h:1444:24
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int sapp_color_format();

        // Function @ sokol_app.h:1446:24
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int sapp_depth_format();

        // Function @ sokol_app.h:1448:24
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int sapp_sample_count();

        // Function @ sokol_app.h:1450:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sapp_high_dpi();

        // Function @ sokol_app.h:1452:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern float sapp_dpi_scale();

        // Function @ sokol_app.h:1454:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_show_keyboard(CBool show);

        // Function @ sokol_app.h:1456:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sapp_keyboard_shown();

        // Function @ sokol_app.h:1458:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sapp_is_fullscreen();

        // Function @ sokol_app.h:1460:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_toggle_fullscreen();

        // Function @ sokol_app.h:1462:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_show_mouse(CBool show);

        // Function @ sokol_app.h:1464:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sapp_mouse_shown();

        // Function @ sokol_app.h:1466:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_lock_mouse(CBool @lock);

        // Function @ sokol_app.h:1468:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sapp_mouse_locked();

        // Function @ sokol_app.h:1470:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_userdata();

        // Function @ sokol_app.h:1472:30
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sapp_desc sapp_query_desc();

        // Function @ sokol_app.h:1474:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_request_quit();

        // Function @ sokol_app.h:1476:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_cancel_quit();

        // Function @ sokol_app.h:1478:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_quit();

        // Function @ sokol_app.h:1480:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_consume_event();

        // Function @ sokol_app.h:1482:29
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong sapp_frame_count();

        // Function @ sokol_app.h:1484:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern double sapp_frame_duration();

        // Function @ sokol_app.h:1486:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_set_clipboard_string(CString str);

        // Function @ sokol_app.h:1488:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CString sapp_get_clipboard_string();

        // Function @ sokol_app.h:1490:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_set_window_title(CString str);

        // Function @ sokol_app.h:1492:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_set_icon(sapp_icon_desc* icon_desc);

        // Function @ sokol_app.h:1494:24
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int sapp_get_num_dropped_files();

        // Function @ sokol_app.h:1496:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CString sapp_get_dropped_file_path(int index);

        // Function @ sokol_app.h:1499:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_run(sapp_desc* desc);

        // Function @ sokol_app.h:1502:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sapp_gles2();

        // Function @ sokol_app.h:1505:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_html5_ask_leave_site(CBool ask);

        // Function @ sokol_app.h:1507:29
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern uint sapp_html5_get_dropped_file_size(int index);

        // Function @ sokol_app.h:1509:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sapp_html5_fetch_dropped_file(sapp_html5_fetch_request* request);

        // Function @ sokol_app.h:1512:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_metal_get_device();

        // Function @ sokol_app.h:1514:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_metal_get_renderpass_descriptor();

        // Function @ sokol_app.h:1516:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_metal_get_drawable();

        // Function @ sokol_app.h:1518:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_macos_get_window();

        // Function @ sokol_app.h:1520:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_ios_get_window();

        // Function @ sokol_app.h:1523:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_d3d11_get_device();

        // Function @ sokol_app.h:1525:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_d3d11_get_device_context();

        // Function @ sokol_app.h:1527:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_d3d11_get_swap_chain();

        // Function @ sokol_app.h:1529:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_d3d11_get_render_target_view();

        // Function @ sokol_app.h:1531:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_d3d11_get_depth_stencil_view();

        // Function @ sokol_app.h:1533:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_win32_get_hwnd();

        // Function @ sokol_app.h:1536:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_wgpu_get_device();

        // Function @ sokol_app.h:1538:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_wgpu_get_render_view();

        // Function @ sokol_app.h:1540:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_wgpu_get_resolve_view();

        // Function @ sokol_app.h:1542:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_wgpu_get_depth_stencil_view();

        // Function @ sokol_app.h:1545:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sapp_android_get_native_activity();

        // Function @ sokol_gfx.h:2419:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_setup(sg_desc* desc);

        // Function @ sokol_gfx.h:2420:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_shutdown();

        // Function @ sokol_gfx.h:2421:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sg_isvalid();

        // Function @ sokol_gfx.h:2422:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_reset_state_cache();

        // Function @ sokol_gfx.h:2423:35
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_trace_hooks sg_install_trace_hooks(sg_trace_hooks* trace_hooks);

        // Function @ sokol_gfx.h:2424:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_push_debug_group(CString name);

        // Function @ sokol_gfx.h:2425:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_pop_debug_group();

        // Function @ sokol_gfx.h:2428:30
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_buffer sg_make_buffer(sg_buffer_desc* desc);

        // Function @ sokol_gfx.h:2429:29
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_image sg_make_image(sg_image_desc* desc);

        // Function @ sokol_gfx.h:2430:30
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_shader sg_make_shader(sg_shader_desc* desc);

        // Function @ sokol_gfx.h:2431:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_pipeline sg_make_pipeline(sg_pipeline_desc* desc);

        // Function @ sokol_gfx.h:2432:28
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_pass sg_make_pass(sg_pass_desc* desc);

        // Function @ sokol_gfx.h:2433:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_destroy_buffer(sg_buffer buf);

        // Function @ sokol_gfx.h:2434:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_destroy_image(sg_image img);

        // Function @ sokol_gfx.h:2435:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_destroy_shader(sg_shader shd);

        // Function @ sokol_gfx.h:2436:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_destroy_pipeline(sg_pipeline pip);

        // Function @ sokol_gfx.h:2437:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_destroy_pass(sg_pass pass);

        // Function @ sokol_gfx.h:2438:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_update_buffer(sg_buffer buf, sg_range* data);

        // Function @ sokol_gfx.h:2439:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_update_image(sg_image img, sg_image_data* data);

        // Function @ sokol_gfx.h:2440:24
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int sg_append_buffer(sg_buffer buf, sg_range* data);

        // Function @ sokol_gfx.h:2441:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sg_query_buffer_overflow(sg_buffer buf);

        // Function @ sokol_gfx.h:2444:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_begin_default_pass(sg_pass_action* pass_action, int width, int height);

        // Function @ sokol_gfx.h:2445:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_begin_default_passf(sg_pass_action* pass_action, float width, float height);

        // Function @ sokol_gfx.h:2446:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_begin_pass(sg_pass pass, sg_pass_action* pass_action);

        // Function @ sokol_gfx.h:2447:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_apply_viewport(int x, int y, int width, int height, CBool origin_top_left);

        // Function @ sokol_gfx.h:2448:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_apply_viewportf(float x, float y, float width, float height, CBool origin_top_left);

        // Function @ sokol_gfx.h:2449:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_apply_scissor_rect(int x, int y, int width, int height, CBool origin_top_left);

        // Function @ sokol_gfx.h:2450:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_apply_scissor_rectf(float x, float y, float width, float height, CBool origin_top_left);

        // Function @ sokol_gfx.h:2451:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_apply_pipeline(sg_pipeline pip);

        // Function @ sokol_gfx.h:2452:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_apply_bindings(sg_bindings* bindings);

        // Function @ sokol_gfx.h:2453:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_apply_uniforms(sg_shader_stage stage, int ub_index, sg_range* data);

        // Function @ sokol_gfx.h:2454:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_draw(int base_element, int num_elements, int num_instances);

        // Function @ sokol_gfx.h:2455:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_end_pass();

        // Function @ sokol_gfx.h:2456:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_commit();

        // Function @ sokol_gfx.h:2459:28
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_desc sg_query_desc();

        // Function @ sokol_gfx.h:2460:31
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_backend sg_query_backend();

        // Function @ sokol_gfx.h:2461:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_features sg_query_features();

        // Function @ sokol_gfx.h:2462:30
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_limits sg_query_limits();

        // Function @ sokol_gfx.h:2463:40
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_pixelformat_info sg_query_pixelformat(sg_pixel_format fmt);

        // Function @ sokol_gfx.h:2465:38
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_resource_state sg_query_buffer_state(sg_buffer buf);

        // Function @ sokol_gfx.h:2466:38
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_resource_state sg_query_image_state(sg_image img);

        // Function @ sokol_gfx.h:2467:38
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_resource_state sg_query_shader_state(sg_shader shd);

        // Function @ sokol_gfx.h:2468:38
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_resource_state sg_query_pipeline_state(sg_pipeline pip);

        // Function @ sokol_gfx.h:2469:38
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_resource_state sg_query_pass_state(sg_pass pass);

        // Function @ sokol_gfx.h:2471:35
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_buffer_info sg_query_buffer_info(sg_buffer buf);

        // Function @ sokol_gfx.h:2472:34
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_image_info sg_query_image_info(sg_image img);

        // Function @ sokol_gfx.h:2473:35
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_shader_info sg_query_shader_info(sg_shader shd);

        // Function @ sokol_gfx.h:2474:37
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_pipeline_info sg_query_pipeline_info(sg_pipeline pip);

        // Function @ sokol_gfx.h:2475:33
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_pass_info sg_query_pass_info(sg_pass pass);

        // Function @ sokol_gfx.h:2477:35
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_buffer_desc sg_query_buffer_defaults(sg_buffer_desc* desc);

        // Function @ sokol_gfx.h:2478:34
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_image_desc sg_query_image_defaults(sg_image_desc* desc);

        // Function @ sokol_gfx.h:2479:35
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_shader_desc sg_query_shader_defaults(sg_shader_desc* desc);

        // Function @ sokol_gfx.h:2480:37
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_pipeline_desc sg_query_pipeline_defaults(sg_pipeline_desc* desc);

        // Function @ sokol_gfx.h:2481:33
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_pass_desc sg_query_pass_defaults(sg_pass_desc* desc);

        // Function @ sokol_gfx.h:2484:30
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_buffer sg_alloc_buffer();

        // Function @ sokol_gfx.h:2485:29
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_image sg_alloc_image();

        // Function @ sokol_gfx.h:2486:30
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_shader sg_alloc_shader();

        // Function @ sokol_gfx.h:2487:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_pipeline sg_alloc_pipeline();

        // Function @ sokol_gfx.h:2488:28
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_pass sg_alloc_pass();

        // Function @ sokol_gfx.h:2489:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_dealloc_buffer(sg_buffer buf_id);

        // Function @ sokol_gfx.h:2490:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_dealloc_image(sg_image img_id);

        // Function @ sokol_gfx.h:2491:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_dealloc_shader(sg_shader shd_id);

        // Function @ sokol_gfx.h:2492:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_dealloc_pipeline(sg_pipeline pip_id);

        // Function @ sokol_gfx.h:2493:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_dealloc_pass(sg_pass pass_id);

        // Function @ sokol_gfx.h:2494:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_init_buffer(sg_buffer buf_id, sg_buffer_desc* desc);

        // Function @ sokol_gfx.h:2495:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_init_image(sg_image img_id, sg_image_desc* desc);

        // Function @ sokol_gfx.h:2496:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_init_shader(sg_shader shd_id, sg_shader_desc* desc);

        // Function @ sokol_gfx.h:2497:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_init_pipeline(sg_pipeline pip_id, sg_pipeline_desc* desc);

        // Function @ sokol_gfx.h:2498:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_init_pass(sg_pass pass_id, sg_pass_desc* desc);

        // Function @ sokol_gfx.h:2499:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sg_uninit_buffer(sg_buffer buf_id);

        // Function @ sokol_gfx.h:2500:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sg_uninit_image(sg_image img_id);

        // Function @ sokol_gfx.h:2501:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sg_uninit_shader(sg_shader shd_id);

        // Function @ sokol_gfx.h:2502:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sg_uninit_pipeline(sg_pipeline pip_id);

        // Function @ sokol_gfx.h:2503:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sg_uninit_pass(sg_pass pass_id);

        // Function @ sokol_gfx.h:2504:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_fail_buffer(sg_buffer buf_id);

        // Function @ sokol_gfx.h:2505:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_fail_image(sg_image img_id);

        // Function @ sokol_gfx.h:2506:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_fail_shader(sg_shader shd_id);

        // Function @ sokol_gfx.h:2507:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_fail_pipeline(sg_pipeline pip_id);

        // Function @ sokol_gfx.h:2508:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_fail_pass(sg_pass pass_id);

        // Function @ sokol_gfx.h:2511:31
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_context sg_setup_context();

        // Function @ sokol_gfx.h:2512:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_activate_context(sg_context ctx_id);

        // Function @ sokol_gfx.h:2513:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sg_discard_context(sg_context ctx_id);

        // Function @ sokol_gfx.h:2522:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sg_d3d11_device();

        // Function @ sokol_gfx.h:2525:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sg_mtl_device();

        // Function @ sokol_gfx.h:2528:32
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sg_mtl_render_command_encoder();

        // Function @ sokol_glue.h:97:37
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sg_context_desc sapp_sgcontext();

        // Function @ sokol_audio.h:427:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void saudio_setup(saudio_desc* desc);

        // Function @ sokol_audio.h:429:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void saudio_shutdown();

        // Function @ sokol_audio.h:431:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool saudio_isvalid();

        // Function @ sokol_audio.h:433:28
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* saudio_userdata();

        // Function @ sokol_audio.h:435:34
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern saudio_desc saudio_query_desc();

        // Function @ sokol_audio.h:437:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int saudio_sample_rate();

        // Function @ sokol_audio.h:439:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int saudio_buffer_frames();

        // Function @ sokol_audio.h:441:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int saudio_channels();

        // Function @ sokol_audio.h:443:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool saudio_suspended();

        // Function @ sokol_audio.h:445:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int saudio_expect();

        // Function @ sokol_audio.h:447:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int saudio_push(float* frames, int num_frames);

        // Function @ sokol_fetch.h:921:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sfetch_setup(sfetch_desc_t* desc);

        // Function @ sokol_fetch.h:923:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sfetch_shutdown();

        // Function @ sokol_fetch.h:925:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sfetch_valid();

        // Function @ sokol_fetch.h:927:36
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sfetch_desc_t sfetch_desc();

        // Function @ sokol_fetch.h:929:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int sfetch_max_userdata_bytes();

        // Function @ sokol_fetch.h:931:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int sfetch_max_path();

        // Function @ sokol_fetch.h:934:38
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern sfetch_handle_t sfetch_send(sfetch_request_t* request);

        // Function @ sokol_fetch.h:936:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sfetch_handle_valid(sfetch_handle_t h);

        // Function @ sokol_fetch.h:938:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sfetch_dowork();

        // Function @ sokol_fetch.h:941:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sfetch_bind_buffer(sfetch_handle_t h, void* buffer_ptr, uint buffer_size);

        // Function @ sokol_fetch.h:943:28
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void* sfetch_unbind_buffer(sfetch_handle_t h);

        // Function @ sokol_fetch.h:945:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sfetch_cancel(sfetch_handle_t h);

        // Function @ sokol_fetch.h:947:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sfetch_pause(sfetch_handle_t h);

        // Function @ sokol_fetch.h:949:27
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sfetch_continue(sfetch_handle_t h);

        // Function @ sokol_time.h:128:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void stm_setup();

        // Function @ sokol_time.h:129:30
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong stm_now();

        // Function @ sokol_time.h:130:30
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong stm_diff(ulong new_ticks, ulong old_ticks);

        // Function @ sokol_time.h:131:30
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong stm_since(ulong start_ticks);

        // Function @ sokol_time.h:132:30
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong stm_laptime(ulong* last_time);

        // Function @ sokol_time.h:133:30
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong stm_round_to_common_refresh_rate(ulong frame_ticks);

        // Function @ sokol_time.h:134:28
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern double stm_sec(ulong ticks);

        // Function @ sokol_time.h:135:28
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern double stm_ms(ulong ticks);

        // Function @ sokol_time.h:136:28
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern double stm_us(ulong ticks);

        // Function @ sokol_time.h:137:28
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern double stm_ns(ulong ticks);

        // Function @ sokol_args.h:280:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sargs_setup(sargs_desc* desc);

        // Function @ sokol_args.h:282:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern void sargs_shutdown();

        // Function @ sokol_args.h:284:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sargs_isvalid();

        // Function @ sokol_args.h:286:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sargs_exists(CString key);

        // Function @ sokol_args.h:288:33
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CString sargs_value(CString key);

        // Function @ sokol_args.h:290:33
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CString sargs_value_def(CString key, CString def);

        // Function @ sokol_args.h:292:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sargs_equals(CString key, CString val);

        // Function @ sokol_args.h:294:26
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CBool sargs_boolean(CString key);

        // Function @ sokol_args.h:296:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int sargs_find(CString key);

        // Function @ sokol_args.h:298:25
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern int sargs_num_args();

        // Function @ sokol_args.h:300:33
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CString sargs_key_at(int index);

        // Function @ sokol_args.h:302:33
        [DllImport(LibraryName, CallingConvention = CallingConvention.Cdecl)]
        public static extern CString sargs_value_at(int index);

        // FunctionPointer @ sokol_app.h:1361:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Void
        {
            public delegate* unmanaged<void> Pointer;
        }

        // FunctionPointer @ sokol_app.h:1364:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sapp_eventPtr_Void
        {
            public delegate* unmanaged<sapp_event*, void> Pointer;
        }

        // FunctionPointer @ sokol_app.h:1365:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_CString_Void
        {
            public delegate* unmanaged<CString, void> Pointer;
        }

        // FunctionPointer @ sokol_app.h:1368:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr_Void
        {
            public delegate* unmanaged<void*, void> Pointer;
        }

        // FunctionPointer @ sokol_app.h:1371:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sapp_eventPtr_VoidPtr_Void
        {
            public delegate* unmanaged<sapp_event*, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_app.h:1372:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_CString_VoidPtr_Void
        {
            public delegate* unmanaged<CString, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_app.h:1424:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sapp_html5_fetch_responsePtr_Void
        {
            public delegate* unmanaged<sapp_html5_fetch_response*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2129:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_buffer_descPtr_Sg_buffer_VoidPtr_Void
        {
            public delegate* unmanaged<sg_buffer_desc*, sg_buffer, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2130:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_image_descPtr_Sg_image_VoidPtr_Void
        {
            public delegate* unmanaged<sg_image_desc*, sg_image, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2131:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_shader_descPtr_Sg_shader_VoidPtr_Void
        {
            public delegate* unmanaged<sg_shader_desc*, sg_shader, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2132:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_pipeline_descPtr_Sg_pipeline_VoidPtr_Void
        {
            public delegate* unmanaged<sg_pipeline_desc*, sg_pipeline, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2133:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_pass_descPtr_Sg_pass_VoidPtr_Void
        {
            public delegate* unmanaged<sg_pass_desc*, sg_pass, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2134:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_buffer_VoidPtr_Void
        {
            public delegate* unmanaged<sg_buffer, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2135:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_image_VoidPtr_Void
        {
            public delegate* unmanaged<sg_image, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2136:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_shader_VoidPtr_Void
        {
            public delegate* unmanaged<sg_shader, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2137:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_pipeline_VoidPtr_Void
        {
            public delegate* unmanaged<sg_pipeline, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2138:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_pass_VoidPtr_Void
        {
            public delegate* unmanaged<sg_pass, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2139:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_buffer_Sg_rangePtr_VoidPtr_Void
        {
            public delegate* unmanaged<sg_buffer, sg_range*, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2140:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_image_Sg_image_dataPtr_VoidPtr_Void
        {
            public delegate* unmanaged<sg_image, sg_image_data*, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2141:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_buffer_Sg_rangePtr_Int_VoidPtr_Void
        {
            public delegate* unmanaged<sg_buffer, sg_range*, int, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2142:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_pass_actionPtr_Int_Int_VoidPtr_Void
        {
            public delegate* unmanaged<sg_pass_action*, int, int, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2143:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_pass_Sg_pass_actionPtr_VoidPtr_Void
        {
            public delegate* unmanaged<sg_pass, sg_pass_action*, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2144:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Int_Int_Int_Int_CBool_VoidPtr_Void
        {
            public delegate* unmanaged<int, int, int, int, CBool, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2147:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_bindingsPtr_VoidPtr_Void
        {
            public delegate* unmanaged<sg_bindings*, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2148:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_shader_stage_Int_Sg_rangePtr_VoidPtr_Void
        {
            public delegate* unmanaged<sg_shader_stage, int, sg_range*, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2149:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Int_Int_Int_VoidPtr_Void
        {
            public delegate* unmanaged<int, int, int, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2162:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_buffer_Sg_buffer_descPtr_VoidPtr_Void
        {
            public delegate* unmanaged<sg_buffer, sg_buffer_desc*, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2163:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_image_Sg_image_descPtr_VoidPtr_Void
        {
            public delegate* unmanaged<sg_image, sg_image_desc*, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2164:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_shader_Sg_shader_descPtr_VoidPtr_Void
        {
            public delegate* unmanaged<sg_shader, sg_shader_desc*, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2165:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_pipeline_Sg_pipeline_descPtr_VoidPtr_Void
        {
            public delegate* unmanaged<sg_pipeline, sg_pipeline_desc*, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2166:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_Sg_pass_Sg_pass_descPtr_VoidPtr_Void
        {
            public delegate* unmanaged<sg_pass, sg_pass_desc*, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_audio.h:421:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_FloatPtr_Int_Int_Void
        {
            public delegate* unmanaged<float*, int, int, void> Pointer;
        }

        // FunctionPointer @ sokol_audio.h:422:12
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_FloatPtr_Int_Int_VoidPtr_Void
        {
            public delegate* unmanaged<float*, int, int, void*, void> Pointer;
        }

        // FunctionPointer @ sokol_fetch.h:904:15
        [StructLayout(LayoutKind.Sequential)]
        public struct sfetch_callback_t
        {
            public delegate* unmanaged<sfetch_response_t*, void> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2365:19
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr
        {
            public delegate* unmanaged<void*> Pointer;
        }

        // FunctionPointer @ sokol_gfx.h:2366:19
        [StructLayout(LayoutKind.Sequential)]
        public struct FnPtr_VoidPtr_VoidPtr
        {
            public delegate* unmanaged<void*, void*> Pointer;
        }

        // Struct @ sokol_app.h:1401:3
        [StructLayout(LayoutKind.Explicit, Size = 368, Pack = 8)]
        public struct sapp_desc
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public FnPtr_Void init_cb;

            [FieldOffset(8)] // size = 8, padding = 0
            public FnPtr_Void frame_cb;

            [FieldOffset(16)] // size = 8, padding = 0
            public FnPtr_Void cleanup_cb;

            [FieldOffset(24)] // size = 8, padding = 0
            public FnPtr_Sapp_eventPtr_Void event_cb;

            [FieldOffset(32)] // size = 8, padding = 0
            public FnPtr_CString_Void fail_cb;

            [FieldOffset(40)] // size = 8, padding = 0
            public void* user_data;

            [FieldOffset(48)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void init_userdata_cb;

            [FieldOffset(56)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void frame_userdata_cb;

            [FieldOffset(64)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void cleanup_userdata_cb;

            [FieldOffset(72)] // size = 8, padding = 0
            public FnPtr_Sapp_eventPtr_VoidPtr_Void event_userdata_cb;

            [FieldOffset(80)] // size = 8, padding = 0
            public FnPtr_CString_VoidPtr_Void fail_userdata_cb;

            [FieldOffset(88)] // size = 4, padding = 0
            public int width;

            [FieldOffset(92)] // size = 4, padding = 0
            public int height;

            [FieldOffset(96)] // size = 4, padding = 0
            public int sample_count;

            [FieldOffset(100)] // size = 4, padding = 0
            public int swap_interval;

            [FieldOffset(104)] // size = 1, padding = 0
            public CBool high_dpi;

            [FieldOffset(105)] // size = 1, padding = 0
            public CBool fullscreen;

            [FieldOffset(106)] // size = 1, padding = 5
            public CBool alpha;

            [FieldOffset(112)] // size = 8, padding = 0
            public CString window_title;

            [FieldOffset(120)] // size = 1, padding = 0
            public CBool user_cursor;

            [FieldOffset(121)] // size = 1, padding = 2
            public CBool enable_clipboard;

            [FieldOffset(124)] // size = 4, padding = 0
            public int clipboard_size;

            [FieldOffset(128)] // size = 1, padding = 3
            public CBool enable_dragndrop;

            [FieldOffset(132)] // size = 4, padding = 0
            public int max_dropped_files;

            [FieldOffset(136)] // size = 4, padding = 4
            public int max_dropped_file_path_length;

            [FieldOffset(144)] // size = 200, padding = 0
            public sapp_icon_desc icon;

            [FieldOffset(344)] // size = 1, padding = 0
            public CBool gl_force_gles2;

            [FieldOffset(345)] // size = 1, padding = 0
            public CBool win32_console_utf8;

            [FieldOffset(346)] // size = 1, padding = 0
            public CBool win32_console_create;

            [FieldOffset(347)] // size = 1, padding = 4
            public CBool win32_console_attach;

            [FieldOffset(352)] // size = 8, padding = 0
            public CString html5_canvas_name;

            [FieldOffset(360)] // size = 1, padding = 0
            public CBool html5_canvas_resize;

            [FieldOffset(361)] // size = 1, padding = 0
            public CBool html5_preserve_drawing_buffer;

            [FieldOffset(362)] // size = 1, padding = 0
            public CBool html5_premultiplied_alpha;

            [FieldOffset(363)] // size = 1, padding = 0
            public CBool html5_ask_leave_site;

            [FieldOffset(364)] // size = 1, padding = 3
            public CBool ios_keyboard_resizes_canvas;
        }

        // Struct @ sokol_app.h:1357:3
        [StructLayout(LayoutKind.Explicit, Size = 200, Pack = 8)]
        public struct sapp_icon_desc
        {
            [FieldOffset(0)] // size = 1, padding = 7
            public CBool sokol_default;

            [FieldOffset(8)] // size = 192, padding = 0
            public fixed ulong _images[192 / 8]; // sapp_image_desc[8]

            public Span<sapp_image_desc> images
            {
                get
                {
                    fixed (sapp_icon_desc* @this = &this)
                    {
                        var pointer = &@this->_images[0];
                        var span = new Span<sapp_image_desc>(pointer, 8);
                        return span;
                    }
                }
            }
        }

        // Struct @ sokol_app.h:1428:3
        [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 8)]
        public struct sapp_html5_fetch_request
        {
            [FieldOffset(0)] // size = 4, padding = 4
            public int dropped_file_index;

            [FieldOffset(8)] // size = 8, padding = 0
            public FnPtr_Sapp_html5_fetch_responsePtr_Void callback;

            [FieldOffset(16)] // size = 8, padding = 0
            public void* buffer_ptr;

            [FieldOffset(24)] // size = 4, padding = 4
            public uint buffer_size;

            [FieldOffset(32)] // size = 8, padding = 0
            public void* user_data;
        }

        // Struct @ sokol_gfx.h:2416:3
        [StructLayout(LayoutKind.Explicit, Size = 232, Pack = 8)]
        public struct sg_desc
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint _start_canary;

            [FieldOffset(4)] // size = 4, padding = 0
            public int buffer_pool_size;

            [FieldOffset(8)] // size = 4, padding = 0
            public int image_pool_size;

            [FieldOffset(12)] // size = 4, padding = 0
            public int shader_pool_size;

            [FieldOffset(16)] // size = 4, padding = 0
            public int pipeline_pool_size;

            [FieldOffset(20)] // size = 4, padding = 0
            public int pass_pool_size;

            [FieldOffset(24)] // size = 4, padding = 0
            public int context_pool_size;

            [FieldOffset(28)] // size = 4, padding = 0
            public int uniform_buffer_size;

            [FieldOffset(32)] // size = 4, padding = 0
            public int staging_buffer_size;

            [FieldOffset(36)] // size = 4, padding = 0
            public int sampler_cache_size;

            [FieldOffset(40)] // size = 184, padding = 0
            public sg_context_desc context;

            [FieldOffset(224)] // size = 4, padding = 4
            public uint _end_canary;
        }

        // Struct @ sokol_gfx.h:2188:3
        [StructLayout(LayoutKind.Explicit, Size = 488, Pack = 8)]
        public struct sg_trace_hooks
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* user_data;

            [FieldOffset(8)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void reset_state_cache;

            [FieldOffset(16)] // size = 8, padding = 0
            public FnPtr_Sg_buffer_descPtr_Sg_buffer_VoidPtr_Void make_buffer;

            [FieldOffset(24)] // size = 8, padding = 0
            public FnPtr_Sg_image_descPtr_Sg_image_VoidPtr_Void make_image;

            [FieldOffset(32)] // size = 8, padding = 0
            public FnPtr_Sg_shader_descPtr_Sg_shader_VoidPtr_Void make_shader;

            [FieldOffset(40)] // size = 8, padding = 0
            public FnPtr_Sg_pipeline_descPtr_Sg_pipeline_VoidPtr_Void make_pipeline;

            [FieldOffset(48)] // size = 8, padding = 0
            public FnPtr_Sg_pass_descPtr_Sg_pass_VoidPtr_Void make_pass;

            [FieldOffset(56)] // size = 8, padding = 0
            public FnPtr_Sg_buffer_VoidPtr_Void destroy_buffer;

            [FieldOffset(64)] // size = 8, padding = 0
            public FnPtr_Sg_image_VoidPtr_Void destroy_image;

            [FieldOffset(72)] // size = 8, padding = 0
            public FnPtr_Sg_shader_VoidPtr_Void destroy_shader;

            [FieldOffset(80)] // size = 8, padding = 0
            public FnPtr_Sg_pipeline_VoidPtr_Void destroy_pipeline;

            [FieldOffset(88)] // size = 8, padding = 0
            public FnPtr_Sg_pass_VoidPtr_Void destroy_pass;

            [FieldOffset(96)] // size = 8, padding = 0
            public FnPtr_Sg_buffer_Sg_rangePtr_VoidPtr_Void update_buffer;

            [FieldOffset(104)] // size = 8, padding = 0
            public FnPtr_Sg_image_Sg_image_dataPtr_VoidPtr_Void update_image;

            [FieldOffset(112)] // size = 8, padding = 0
            public FnPtr_Sg_buffer_Sg_rangePtr_Int_VoidPtr_Void append_buffer;

            [FieldOffset(120)] // size = 8, padding = 0
            public FnPtr_Sg_pass_actionPtr_Int_Int_VoidPtr_Void begin_default_pass;

            [FieldOffset(128)] // size = 8, padding = 0
            public FnPtr_Sg_pass_Sg_pass_actionPtr_VoidPtr_Void begin_pass;

            [FieldOffset(136)] // size = 8, padding = 0
            public FnPtr_Int_Int_Int_Int_CBool_VoidPtr_Void apply_viewport;

            [FieldOffset(144)] // size = 8, padding = 0
            public FnPtr_Int_Int_Int_Int_CBool_VoidPtr_Void apply_scissor_rect;

            [FieldOffset(152)] // size = 8, padding = 0
            public FnPtr_Sg_pipeline_VoidPtr_Void apply_pipeline;

            [FieldOffset(160)] // size = 8, padding = 0
            public FnPtr_Sg_bindingsPtr_VoidPtr_Void apply_bindings;

            [FieldOffset(168)] // size = 8, padding = 0
            public FnPtr_Sg_shader_stage_Int_Sg_rangePtr_VoidPtr_Void apply_uniforms;

            [FieldOffset(176)] // size = 8, padding = 0
            public FnPtr_Int_Int_Int_VoidPtr_Void draw;

            [FieldOffset(184)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void end_pass;

            [FieldOffset(192)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void commit;

            [FieldOffset(200)] // size = 8, padding = 0
            public FnPtr_Sg_buffer_VoidPtr_Void alloc_buffer;

            [FieldOffset(208)] // size = 8, padding = 0
            public FnPtr_Sg_image_VoidPtr_Void alloc_image;

            [FieldOffset(216)] // size = 8, padding = 0
            public FnPtr_Sg_shader_VoidPtr_Void alloc_shader;

            [FieldOffset(224)] // size = 8, padding = 0
            public FnPtr_Sg_pipeline_VoidPtr_Void alloc_pipeline;

            [FieldOffset(232)] // size = 8, padding = 0
            public FnPtr_Sg_pass_VoidPtr_Void alloc_pass;

            [FieldOffset(240)] // size = 8, padding = 0
            public FnPtr_Sg_buffer_VoidPtr_Void dealloc_buffer;

            [FieldOffset(248)] // size = 8, padding = 0
            public FnPtr_Sg_image_VoidPtr_Void dealloc_image;

            [FieldOffset(256)] // size = 8, padding = 0
            public FnPtr_Sg_shader_VoidPtr_Void dealloc_shader;

            [FieldOffset(264)] // size = 8, padding = 0
            public FnPtr_Sg_pipeline_VoidPtr_Void dealloc_pipeline;

            [FieldOffset(272)] // size = 8, padding = 0
            public FnPtr_Sg_pass_VoidPtr_Void dealloc_pass;

            [FieldOffset(280)] // size = 8, padding = 0
            public FnPtr_Sg_buffer_Sg_buffer_descPtr_VoidPtr_Void init_buffer;

            [FieldOffset(288)] // size = 8, padding = 0
            public FnPtr_Sg_image_Sg_image_descPtr_VoidPtr_Void init_image;

            [FieldOffset(296)] // size = 8, padding = 0
            public FnPtr_Sg_shader_Sg_shader_descPtr_VoidPtr_Void init_shader;

            [FieldOffset(304)] // size = 8, padding = 0
            public FnPtr_Sg_pipeline_Sg_pipeline_descPtr_VoidPtr_Void init_pipeline;

            [FieldOffset(312)] // size = 8, padding = 0
            public FnPtr_Sg_pass_Sg_pass_descPtr_VoidPtr_Void init_pass;

            [FieldOffset(320)] // size = 8, padding = 0
            public FnPtr_Sg_buffer_VoidPtr_Void uninit_buffer;

            [FieldOffset(328)] // size = 8, padding = 0
            public FnPtr_Sg_image_VoidPtr_Void uninit_image;

            [FieldOffset(336)] // size = 8, padding = 0
            public FnPtr_Sg_shader_VoidPtr_Void uninit_shader;

            [FieldOffset(344)] // size = 8, padding = 0
            public FnPtr_Sg_pipeline_VoidPtr_Void uninit_pipeline;

            [FieldOffset(352)] // size = 8, padding = 0
            public FnPtr_Sg_pass_VoidPtr_Void uninit_pass;

            [FieldOffset(360)] // size = 8, padding = 0
            public FnPtr_Sg_buffer_VoidPtr_Void fail_buffer;

            [FieldOffset(368)] // size = 8, padding = 0
            public FnPtr_Sg_image_VoidPtr_Void fail_image;

            [FieldOffset(376)] // size = 8, padding = 0
            public FnPtr_Sg_shader_VoidPtr_Void fail_shader;

            [FieldOffset(384)] // size = 8, padding = 0
            public FnPtr_Sg_pipeline_VoidPtr_Void fail_pipeline;

            [FieldOffset(392)] // size = 8, padding = 0
            public FnPtr_Sg_pass_VoidPtr_Void fail_pass;

            [FieldOffset(400)] // size = 8, padding = 0
            public FnPtr_CString_VoidPtr_Void push_debug_group;

            [FieldOffset(408)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void pop_debug_group;

            [FieldOffset(416)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void err_buffer_pool_exhausted;

            [FieldOffset(424)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void err_image_pool_exhausted;

            [FieldOffset(432)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void err_shader_pool_exhausted;

            [FieldOffset(440)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void err_pipeline_pool_exhausted;

            [FieldOffset(448)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void err_pass_pool_exhausted;

            [FieldOffset(456)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void err_context_mismatch;

            [FieldOffset(464)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void err_pass_invalid;

            [FieldOffset(472)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void err_draw_invalid;

            [FieldOffset(480)] // size = 8, padding = 0
            public FnPtr_VoidPtr_Void err_bindings_invalid;
        }

        // Struct @ sokol_gfx.h:730:45
        [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
        public struct sg_buffer
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint id;
        }

        // Struct @ sokol_gfx.h:1731:3
        [StructLayout(LayoutKind.Explicit, Size = 96, Pack = 8)]
        public struct sg_buffer_desc
        {
            [FieldOffset(0)] // size = 4, padding = 4
            public uint _start_canary;

            [FieldOffset(8)] // size = 8, padding = 0
            public ulong size;

            [FieldOffset(16)] // size = 4, padding = 0
            public sg_buffer_type type;

            [FieldOffset(20)] // size = 4, padding = 0
            public sg_usage usage;

            [FieldOffset(24)] // size = 16, padding = 0
            public sg_range data;

            [FieldOffset(40)] // size = 8, padding = 0
            public CString label;

            [FieldOffset(48)] // size = 8, padding = 0
            public fixed uint _gl_buffers[8 / 4]; // uint32_t[2]

            public Span<uint> gl_buffers
            {
                get
                {
                    fixed (sg_buffer_desc* @this = &this)
                    {
                        var pointer = &@this->_gl_buffers[0];
                        var span = new Span<uint>(pointer, 2);
                        return span;
                    }
                }
            }

            [FieldOffset(56)] // size = 16, padding = 0
            public fixed ulong _mtl_buffers[16 / 8]; // void*[2]

            public Span<nint> mtl_buffers
            {
                get
                {
                    fixed (sg_buffer_desc* @this = &this)
                    {
                        var pointer = &@this->_mtl_buffers[0];
                        var span = new Span<nint>(pointer, 2);
                        return span;
                    }
                }
            }

            [FieldOffset(72)] // size = 8, padding = 0
            public void* d3d11_buffer;

            [FieldOffset(80)] // size = 8, padding = 0
            public void* wgpu_buffer;

            [FieldOffset(88)] // size = 4, padding = 4
            public uint _end_canary;
        }

        // Struct @ sokol_gfx.h:731:45
        [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
        public struct sg_image
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint id;
        }

        // Struct @ sokol_gfx.h:1847:3
        [StructLayout(LayoutKind.Explicit, Size = 1688, Pack = 8)]
        public struct sg_image_desc
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint _start_canary;

            [FieldOffset(4)] // size = 4, padding = 0
            public sg_image_type type;

            [FieldOffset(8)] // size = 1, padding = 3
            public CBool render_target;

            [FieldOffset(12)] // size = 4, padding = 0
            public int width;

            [FieldOffset(16)] // size = 4, padding = 0
            public int height;

            [FieldOffset(20)] // size = 4, padding = 0
            public int num_slices;

            [FieldOffset(24)] // size = 4, padding = 0
            public int num_mipmaps;

            [FieldOffset(28)] // size = 4, padding = 0
            public sg_usage usage;

            [FieldOffset(32)] // size = 4, padding = 0
            public sg_pixel_format pixel_format;

            [FieldOffset(36)] // size = 4, padding = 0
            public int sample_count;

            [FieldOffset(40)] // size = 4, padding = 0
            public sg_filter min_filter;

            [FieldOffset(44)] // size = 4, padding = 0
            public sg_filter mag_filter;

            [FieldOffset(48)] // size = 4, padding = 0
            public sg_wrap wrap_u;

            [FieldOffset(52)] // size = 4, padding = 0
            public sg_wrap wrap_v;

            [FieldOffset(56)] // size = 4, padding = 0
            public sg_wrap wrap_w;

            [FieldOffset(60)] // size = 4, padding = 0
            public sg_border_color border_color;

            [FieldOffset(64)] // size = 4, padding = 0
            public uint max_anisotropy;

            [FieldOffset(68)] // size = 4, padding = 0
            public float min_lod;

            [FieldOffset(72)] // size = 4, padding = 4
            public float max_lod;

            [FieldOffset(80)] // size = 1536, padding = 0
            public sg_image_data data;

            [FieldOffset(1616)] // size = 8, padding = 0
            public CString label;

            [FieldOffset(1624)] // size = 8, padding = 0
            public fixed uint _gl_textures[8 / 4]; // uint32_t[2]

            public Span<uint> gl_textures
            {
                get
                {
                    fixed (sg_image_desc* @this = &this)
                    {
                        var pointer = &@this->_gl_textures[0];
                        var span = new Span<uint>(pointer, 2);
                        return span;
                    }
                }
            }

            [FieldOffset(1632)] // size = 4, padding = 4
            public uint gl_texture_target;

            [FieldOffset(1640)] // size = 16, padding = 0
            public fixed ulong _mtl_textures[16 / 8]; // void*[2]

            public Span<nint> mtl_textures
            {
                get
                {
                    fixed (sg_image_desc* @this = &this)
                    {
                        var pointer = &@this->_mtl_textures[0];
                        var span = new Span<nint>(pointer, 2);
                        return span;
                    }
                }
            }

            [FieldOffset(1656)] // size = 8, padding = 0
            public void* d3d11_texture;

            [FieldOffset(1664)] // size = 8, padding = 0
            public void* d3d11_shader_resource_view;

            [FieldOffset(1672)] // size = 8, padding = 0
            public void* wgpu_texture;

            [FieldOffset(1680)] // size = 4, padding = 4
            public uint _end_canary;
        }

        // Struct @ sokol_gfx.h:732:45
        [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
        public struct sg_shader
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint id;
        }

        // Struct @ sokol_gfx.h:1924:3
        [StructLayout(LayoutKind.Explicit, Size = 3048, Pack = 8)]
        public struct sg_shader_desc
        {
            [FieldOffset(0)] // size = 4, padding = 4
            public uint _start_canary;

            [FieldOffset(8)] // size = 384, padding = 0
            public fixed ulong _attrs[384 / 8]; // sg_shader_attr_desc[16]

            public Span<sg_shader_attr_desc> attrs
            {
                get
                {
                    fixed (sg_shader_desc* @this = &this)
                    {
                        var pointer = &@this->_attrs[0];
                        var span = new Span<sg_shader_attr_desc>(pointer, 16);
                        return span;
                    }
                }
            }

            [FieldOffset(392)] // size = 1320, padding = 0
            public sg_shader_stage_desc vs;

            [FieldOffset(1712)] // size = 1320, padding = 0
            public sg_shader_stage_desc fs;

            [FieldOffset(3032)] // size = 8, padding = 0
            public CString label;

            [FieldOffset(3040)] // size = 4, padding = 4
            public uint _end_canary;
        }

        // Struct @ sokol_gfx.h:733:45
        [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
        public struct sg_pipeline
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint id;
        }

        // Struct @ sokol_gfx.h:2076:3
        [StructLayout(LayoutKind.Explicit, Size = 568, Pack = 8)]
        public struct sg_pipeline_desc
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint _start_canary;

            [FieldOffset(4)] // size = 4, padding = 0
            public sg_shader shader;

            [FieldOffset(8)] // size = 288, padding = 0
            public sg_layout_desc layout;

            [FieldOffset(296)] // size = 24, padding = 0
            public sg_depth_state depth;

            [FieldOffset(320)] // size = 40, padding = 0
            public sg_stencil_state stencil;

            [FieldOffset(360)] // size = 4, padding = 0
            public int color_count;

            [FieldOffset(364)] // size = 144, padding = 0
            public fixed uint _colors[144 / 4]; // sg_color_state[4]

            public Span<sg_color_state> colors
            {
                get
                {
                    fixed (sg_pipeline_desc* @this = &this)
                    {
                        var pointer = &@this->_colors[0];
                        var span = new Span<sg_color_state>(pointer, 4);
                        return span;
                    }
                }
            }

            [FieldOffset(508)] // size = 4, padding = 0
            public sg_primitive_type primitive_type;

            [FieldOffset(512)] // size = 4, padding = 0
            public sg_index_type index_type;

            [FieldOffset(516)] // size = 4, padding = 0
            public sg_cull_mode cull_mode;

            [FieldOffset(520)] // size = 4, padding = 0
            public sg_face_winding face_winding;

            [FieldOffset(524)] // size = 4, padding = 0
            public int sample_count;

            [FieldOffset(528)] // size = 16, padding = 0
            public Rgba32F blend_color;

            [FieldOffset(544)] // size = 1, padding = 7
            public CBool alpha_to_coverage_enabled;

            [FieldOffset(552)] // size = 8, padding = 0
            public CString label;

            [FieldOffset(560)] // size = 4, padding = 4
            public uint _end_canary;
        }

        // Struct @ sokol_gfx.h:734:45
        [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
        public struct sg_pass
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint id;
        }

        // Struct @ sokol_gfx.h:2112:3
        [StructLayout(LayoutKind.Explicit, Size = 80, Pack = 8)]
        public struct sg_pass_desc
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint _start_canary;

            [FieldOffset(4)] // size = 48, padding = 0
            public fixed uint _color_attachments[48 / 4]; // sg_pass_attachment_desc[4]

            public Span<sg_pass_attachment_desc> color_attachments
            {
                get
                {
                    fixed (sg_pass_desc* @this = &this)
                    {
                        var pointer = &@this->_color_attachments[0];
                        var span = new Span<sg_pass_attachment_desc>(pointer, 4);
                        return span;
                    }
                }
            }

            [FieldOffset(52)] // size = 12, padding = 0
            public sg_pass_attachment_desc depth_stencil_attachment;

            [FieldOffset(64)] // size = 8, padding = 0
            public CString label;

            [FieldOffset(72)] // size = 4, padding = 4
            public uint _end_canary;
        }

        // Struct @ sokol_gfx.h:747:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct sg_range
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* ptr;

            [FieldOffset(8)] // size = 8, padding = 0
            public ulong size;
        }

        // Struct @ sokol_gfx.h:1742:3
        [StructLayout(LayoutKind.Explicit, Size = 1536, Pack = 8)]
        public struct sg_image_data
        {
            [FieldOffset(0)] // size = 1536, padding = 0
            public fixed ulong _subimage[1536 / 8]; // sg_range[6]

            public Span<sg_range> subimage
            {
                get
                {
                    fixed (sg_image_data* @this = &this)
                    {
                        var pointer = &@this->_subimage[0];
                        var span = new Span<sg_range>(pointer, 6);
                        return span;
                    }
                }
            }
        }

        // Struct @ sokol_gfx.h:1626:3
        [StructLayout(LayoutKind.Explicit, Size = 104, Pack = 4)]
        public struct sg_pass_action
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint _start_canary;

            [FieldOffset(4)] // size = 80, padding = 0
            public fixed uint _colors[80 / 4]; // sg_color_attachment_action[4]

            public Span<sg_color_attachment_action> colors
            {
                get
                {
                    fixed (sg_pass_action* @this = &this)
                    {
                        var pointer = &@this->_colors[0];
                        var span = new Span<sg_color_attachment_action>(pointer, 4);
                        return span;
                    }
                }
            }

            [FieldOffset(84)] // size = 8, padding = 0
            public sg_depth_attachment_action depth;

            [FieldOffset(92)] // size = 8, padding = 0
            public sg_stencil_attachment_action stencil;

            [FieldOffset(100)] // size = 4, padding = 0
            public uint _end_canary;
        }

        // Struct @ sokol_gfx.h:1660:3
        [StructLayout(LayoutKind.Explicit, Size = 176, Pack = 4)]
        public struct sg_bindings
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint _start_canary;

            [FieldOffset(4)] // size = 32, padding = 0
            public fixed uint _vertex_buffers[32 / 4]; // sg_buffer[8]

            public Span<sg_buffer> vertex_buffers
            {
                get
                {
                    fixed (sg_bindings* @this = &this)
                    {
                        var pointer = &@this->_vertex_buffers[0];
                        var span = new Span<sg_buffer>(pointer, 8);
                        return span;
                    }
                }
            }

            [FieldOffset(36)] // size = 32, padding = 0
            public fixed uint _vertex_buffer_offsets[32 / 4]; // int[8]

            public Span<int> vertex_buffer_offsets
            {
                get
                {
                    fixed (sg_bindings* @this = &this)
                    {
                        var pointer = &@this->_vertex_buffer_offsets[0];
                        var span = new Span<int>(pointer, 8);
                        return span;
                    }
                }
            }

            [FieldOffset(68)] // size = 4, padding = 0
            public sg_buffer index_buffer;

            [FieldOffset(72)] // size = 4, padding = 0
            public int index_buffer_offset;

            [FieldOffset(76)] // size = 48, padding = 0
            public fixed uint _vs_images[48 / 4]; // sg_image[12]

            public Span<sg_image> vs_images
            {
                get
                {
                    fixed (sg_bindings* @this = &this)
                    {
                        var pointer = &@this->_vs_images[0];
                        var span = new Span<sg_image>(pointer, 12);
                        return span;
                    }
                }
            }

            [FieldOffset(124)] // size = 48, padding = 0
            public fixed uint _fs_images[48 / 4]; // sg_image[12]

            public Span<sg_image> fs_images
            {
                get
                {
                    fixed (sg_bindings* @this = &this)
                    {
                        var pointer = &@this->_fs_images[0];
                        var span = new Span<sg_image>(pointer, 12);
                        return span;
                    }
                }
            }

            [FieldOffset(172)] // size = 4, padding = 0
            public uint _end_canary;
        }

        // Struct @ sokol_gfx.h:965:3
        [StructLayout(LayoutKind.Explicit, Size = 9, Pack = 1)]
        public struct sg_features
        {
            [FieldOffset(0)] // size = 1, padding = 0
            public CBool instancing;

            [FieldOffset(1)] // size = 1, padding = 0
            public CBool origin_top_left;

            [FieldOffset(2)] // size = 1, padding = 0
            public CBool multiple_render_targets;

            [FieldOffset(3)] // size = 1, padding = 0
            public CBool msaa_render_targets;

            [FieldOffset(4)] // size = 1, padding = 0
            public CBool imagetype_3d;

            [FieldOffset(5)] // size = 1, padding = 0
            public CBool imagetype_array;

            [FieldOffset(6)] // size = 1, padding = 0
            public CBool image_clamp_to_border;

            [FieldOffset(7)] // size = 1, padding = 0
            public CBool mrt_independent_blend_state;

            [FieldOffset(8)] // size = 1, padding = 0
            public CBool mrt_independent_write_mask;
        }

        // Struct @ sokol_gfx.h:978:3
        [StructLayout(LayoutKind.Explicit, Size = 28, Pack = 4)]
        public struct sg_limits
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int max_image_size_2d;

            [FieldOffset(4)] // size = 4, padding = 0
            public int max_image_size_cube;

            [FieldOffset(8)] // size = 4, padding = 0
            public int max_image_size_3d;

            [FieldOffset(12)] // size = 4, padding = 0
            public int max_image_size_array;

            [FieldOffset(16)] // size = 4, padding = 0
            public int max_image_array_layers;

            [FieldOffset(20)] // size = 4, padding = 0
            public int max_vertex_attrs;

            [FieldOffset(24)] // size = 4, padding = 0
            public int gl_max_vertex_uniform_vectors;
        }

        // Struct @ sokol_gfx.h:946:3
        [StructLayout(LayoutKind.Explicit, Size = 6, Pack = 1)]
        public struct sg_pixelformat_info
        {
            [FieldOffset(0)] // size = 1, padding = 0
            public CBool sample;

            [FieldOffset(1)] // size = 1, padding = 0
            public CBool filter;

            [FieldOffset(2)] // size = 1, padding = 0
            public CBool render;

            [FieldOffset(3)] // size = 1, padding = 0
            public CBool blend;

            [FieldOffset(4)] // size = 1, padding = 0
            public CBool msaa;

            [FieldOffset(5)] // size = 1, padding = 0
            public CBool depth;
        }

        // Struct @ sokol_gfx.h:2225:3
        [StructLayout(LayoutKind.Explicit, Size = 36, Pack = 4)]
        public struct sg_buffer_info
        {
            [FieldOffset(0)] // size = 12, padding = 0
            public sg_slot_info slot;

            [FieldOffset(12)] // size = 4, padding = 0
            public uint update_frame_index;

            [FieldOffset(16)] // size = 4, padding = 0
            public uint append_frame_index;

            [FieldOffset(20)] // size = 4, padding = 0
            public int append_pos;

            [FieldOffset(24)] // size = 1, padding = 3
            public CBool append_overflow;

            [FieldOffset(28)] // size = 4, padding = 0
            public int num_slots;

            [FieldOffset(32)] // size = 4, padding = 0
            public int active_slot;
        }

        // Struct @ sokol_gfx.h:2234:3
        [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 4)]
        public struct sg_image_info
        {
            [FieldOffset(0)] // size = 12, padding = 0
            public sg_slot_info slot;

            [FieldOffset(12)] // size = 4, padding = 0
            public uint upd_frame_index;

            [FieldOffset(16)] // size = 4, padding = 0
            public int num_slots;

            [FieldOffset(20)] // size = 4, padding = 0
            public int active_slot;

            [FieldOffset(24)] // size = 4, padding = 0
            public int width;

            [FieldOffset(28)] // size = 4, padding = 0
            public int height;
        }

        // Struct @ sokol_gfx.h:2238:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
        public struct sg_shader_info
        {
            [FieldOffset(0)] // size = 12, padding = 0
            public sg_slot_info slot;
        }

        // Struct @ sokol_gfx.h:2242:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
        public struct sg_pipeline_info
        {
            [FieldOffset(0)] // size = 12, padding = 0
            public sg_slot_info slot;
        }

        // Struct @ sokol_gfx.h:2246:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
        public struct sg_pass_info
        {
            [FieldOffset(0)] // size = 12, padding = 0
            public sg_slot_info slot;
        }

        // Struct @ sokol_gfx.h:735:45
        [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
        public struct sg_context
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint id;
        }

        // Struct @ sokol_gfx.h:2401:3
        [StructLayout(LayoutKind.Explicit, Size = 184, Pack = 8)]
        public struct sg_context_desc
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public sg_pixel_format color_format;

            [FieldOffset(4)] // size = 4, padding = 0
            public sg_pixel_format depth_format;

            [FieldOffset(8)] // size = 4, padding = 0
            public int sample_count;

            [FieldOffset(12)] // size = 1, padding = 3
            public sg_gl_context_desc gl;

            [FieldOffset(16)] // size = 48, padding = 0
            public sg_metal_context_desc metal;

            [FieldOffset(64)] // size = 56, padding = 0
            public sg_d3d11_context_desc d3d11;

            [FieldOffset(120)] // size = 64, padding = 0
            public sg_wgpu_context_desc wgpu;
        }

        // Struct @ sokol_audio.h:424:3
        [StructLayout(LayoutKind.Explicit, Size = 48, Pack = 8)]
        public struct saudio_desc
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int sample_rate;

            [FieldOffset(4)] // size = 4, padding = 0
            public int num_channels;

            [FieldOffset(8)] // size = 4, padding = 0
            public int buffer_frames;

            [FieldOffset(12)] // size = 4, padding = 0
            public int packet_frames;

            [FieldOffset(16)] // size = 4, padding = 4
            public int num_packets;

            [FieldOffset(24)] // size = 8, padding = 0
            public FnPtr_FloatPtr_Int_Int_Void stream_cb;

            [FieldOffset(32)] // size = 8, padding = 0
            public FnPtr_FloatPtr_Int_Int_VoidPtr_Void stream_userdata_cb;

            [FieldOffset(40)] // size = 8, padding = 0
            public void* user_data;
        }

        // Struct @ sokol_fetch.h:867:3
        [StructLayout(LayoutKind.Explicit, Size = 20, Pack = 4)]
        public struct sfetch_desc_t
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint _start_canary;

            [FieldOffset(4)] // size = 4, padding = 0
            public uint max_requests;

            [FieldOffset(8)] // size = 4, padding = 0
            public uint num_channels;

            [FieldOffset(12)] // size = 4, padding = 0
            public uint num_lanes;

            [FieldOffset(16)] // size = 4, padding = 0
            public uint _end_canary;
        }

        // Struct @ sokol_fetch.h:870:49
        [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
        public struct sfetch_handle_t
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint id;
        }

        // Struct @ sokol_fetch.h:918:3
        [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
        public struct sfetch_request_t
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public uint _start_canary;

            [FieldOffset(4)] // size = 4, padding = 0
            public uint channel;

            [FieldOffset(8)] // size = 8, padding = 0
            public CString path;

            [FieldOffset(16)] // size = 8, padding = 0
            public sfetch_callback_t callback;

            [FieldOffset(24)] // size = 8, padding = 0
            public void* buffer_ptr;

            [FieldOffset(32)] // size = 4, padding = 0
            public uint buffer_size;

            [FieldOffset(36)] // size = 4, padding = 0
            public uint chunk_size;

            [FieldOffset(40)] // size = 8, padding = 0
            public void* user_data_ptr;

            [FieldOffset(48)] // size = 4, padding = 0
            public uint user_data_size;

            [FieldOffset(52)] // size = 4, padding = 0
            public uint _end_canary;
        }

        // Struct @ sokol_args.h:277:3
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct sargs_desc
        {
            [FieldOffset(0)] // size = 4, padding = 4
            public int argc;

            [FieldOffset(8)] // size = 8, padding = 0
            public CString* argv;

            [FieldOffset(16)] // size = 4, padding = 0
            public int max_args;

            [FieldOffset(20)] // size = 4, padding = 0
            public int buf_size;
        }

        // Struct @ sokol_gfx.h:1915:3
        [StructLayout(LayoutKind.Explicit, Size = 1320, Pack = 8)]
        public struct sg_shader_stage_desc
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public CString source;

            [FieldOffset(8)] // size = 16, padding = 0
            public sg_range bytecode;

            [FieldOffset(24)] // size = 8, padding = 0
            public CString entry;

            [FieldOffset(32)] // size = 8, padding = 0
            public CString d3d11_target;

            [FieldOffset(40)] // size = 1088, padding = 0
            public fixed ulong _uniform_blocks[1088 / 8]; // sg_shader_uniform_block_desc[4]

            public Span<sg_shader_uniform_block_desc> uniform_blocks
            {
                get
                {
                    fixed (sg_shader_stage_desc* @this = &this)
                    {
                        var pointer = &@this->_uniform_blocks[0];
                        var span = new Span<sg_shader_uniform_block_desc>(pointer, 4);
                        return span;
                    }
                }
            }

            [FieldOffset(1128)] // size = 192, padding = 0
            public fixed ulong _images[192 / 8]; // sg_shader_image_desc[12]

            public Span<sg_shader_image_desc> images
            {
                get
                {
                    fixed (sg_shader_stage_desc* @this = &this)
                    {
                        var pointer = &@this->_images[0];
                        var span = new Span<sg_shader_image_desc>(pointer, 12);
                        return span;
                    }
                }
            }
        }

        // Struct @ sokol_gfx.h:2016:3
        [StructLayout(LayoutKind.Explicit, Size = 288, Pack = 4)]
        public struct sg_layout_desc
        {
            [FieldOffset(0)] // size = 96, padding = 0
            public fixed uint _buffers[96 / 4]; // sg_buffer_layout_desc[8]

            public Span<sg_buffer_layout_desc> buffers
            {
                get
                {
                    fixed (sg_layout_desc* @this = &this)
                    {
                        var pointer = &@this->_buffers[0];
                        var span = new Span<sg_buffer_layout_desc>(pointer, 8);
                        return span;
                    }
                }
            }

            [FieldOffset(96)] // size = 192, padding = 0
            public fixed uint _attrs[192 / 4]; // sg_vertex_attr_desc[16]

            public Span<sg_vertex_attr_desc> attrs
            {
                get
                {
                    fixed (sg_layout_desc* @this = &this)
                    {
                        var pointer = &@this->_attrs[0];
                        var span = new Span<sg_vertex_attr_desc>(pointer, 16);
                        return span;
                    }
                }
            }
        }

        // Struct @ sokol_gfx.h:2041:3
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 4)]
        public struct sg_depth_state
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public sg_pixel_format pixel_format;

            [FieldOffset(4)] // size = 4, padding = 0
            public sg_compare_func compare;

            [FieldOffset(8)] // size = 1, padding = 3
            public CBool write_enabled;

            [FieldOffset(12)] // size = 4, padding = 0
            public float bias;

            [FieldOffset(16)] // size = 4, padding = 0
            public float bias_slope_scale;

            [FieldOffset(20)] // size = 4, padding = 0
            public float bias_clamp;
        }

        // Struct @ sokol_gfx.h:2032:3
        [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 4)]
        public struct sg_stencil_state
        {
            [FieldOffset(0)] // size = 1, padding = 3
            public CBool enabled;

            [FieldOffset(4)] // size = 16, padding = 0
            public sg_stencil_face_state front;

            [FieldOffset(20)] // size = 16, padding = 0
            public sg_stencil_face_state back;

            [FieldOffset(36)] // size = 1, padding = 0
            public byte read_mask;

            [FieldOffset(37)] // size = 1, padding = 0
            public byte write_mask;

            [FieldOffset(38)] // size = 1, padding = 1
            public byte @ref;
        }

        // Struct @ sokol_gfx.h:2104:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
        public struct sg_pass_attachment_desc
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public sg_image image;

            [FieldOffset(4)] // size = 4, padding = 0
            public int mip_level;

            [FieldOffset(8)] // size = 4, padding = 0
            public int slice;
        }

        // Struct @ sokol_gfx.h:1613:3
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 4)]
        public struct sg_depth_attachment_action
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public sg_action action;

            [FieldOffset(4)] // size = 4, padding = 0
            public float value;
        }

        // Struct @ sokol_gfx.h:1618:3
        [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 4)]
        public struct sg_stencil_attachment_action
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public sg_action action;

            [FieldOffset(4)] // size = 1, padding = 3
            public byte value;
        }

        // Struct @ sokol_gfx.h:2215:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
        public struct sg_slot_info
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public sg_resource_state state;

            [FieldOffset(4)] // size = 4, padding = 0
            public uint res_id;

            [FieldOffset(8)] // size = 4, padding = 0
            public uint ctx_id;
        }

        // Struct @ sokol_gfx.h:2361:3
        [StructLayout(LayoutKind.Explicit, Size = 1, Pack = 1)]
        public struct sg_gl_context_desc
        {
            [FieldOffset(0)] // size = 1, padding = 0
            public CBool force_gles2;
        }

        // Struct @ sokol_gfx.h:2370:3
        [StructLayout(LayoutKind.Explicit, Size = 48, Pack = 8)]
        public struct sg_metal_context_desc
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* device;

            [FieldOffset(8)] // size = 8, padding = 0
            public FnPtr_VoidPtr renderpass_descriptor_cb;

            [FieldOffset(16)] // size = 8, padding = 0
            public FnPtr_VoidPtr_VoidPtr renderpass_descriptor_userdata_cb;

            [FieldOffset(24)] // size = 8, padding = 0
            public FnPtr_VoidPtr drawable_cb;

            [FieldOffset(32)] // size = 8, padding = 0
            public FnPtr_VoidPtr_VoidPtr drawable_userdata_cb;

            [FieldOffset(40)] // size = 8, padding = 0
            public void* user_data;
        }

        // Struct @ sokol_gfx.h:2380:3
        [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
        public struct sg_d3d11_context_desc
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* device;

            [FieldOffset(8)] // size = 8, padding = 0
            public void* device_context;

            [FieldOffset(16)] // size = 8, padding = 0
            public FnPtr_VoidPtr render_target_view_cb;

            [FieldOffset(24)] // size = 8, padding = 0
            public FnPtr_VoidPtr_VoidPtr render_target_view_userdata_cb;

            [FieldOffset(32)] // size = 8, padding = 0
            public FnPtr_VoidPtr depth_stencil_view_cb;

            [FieldOffset(40)] // size = 8, padding = 0
            public FnPtr_VoidPtr_VoidPtr depth_stencil_view_userdata_cb;

            [FieldOffset(48)] // size = 8, padding = 0
            public void* user_data;
        }

        // Struct @ sokol_gfx.h:2391:3
        [StructLayout(LayoutKind.Explicit, Size = 64, Pack = 8)]
        public struct sg_wgpu_context_desc
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* device;

            [FieldOffset(8)] // size = 8, padding = 0
            public FnPtr_VoidPtr render_view_cb;

            [FieldOffset(16)] // size = 8, padding = 0
            public FnPtr_VoidPtr_VoidPtr render_view_userdata_cb;

            [FieldOffset(24)] // size = 8, padding = 0
            public FnPtr_VoidPtr resolve_view_cb;

            [FieldOffset(32)] // size = 8, padding = 0
            public FnPtr_VoidPtr_VoidPtr resolve_view_userdata_cb;

            [FieldOffset(40)] // size = 8, padding = 0
            public FnPtr_VoidPtr depth_stencil_view_cb;

            [FieldOffset(48)] // size = 8, padding = 0
            public FnPtr_VoidPtr_VoidPtr depth_stencil_view_userdata_cb;

            [FieldOffset(56)] // size = 8, padding = 0
            public void* user_data;
        }

        // Struct @ sokol_app.h:1296:3
        [StructLayout(LayoutKind.Explicit, Size = 272, Pack = 8)]
        public struct sapp_event
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public ulong frame_count;

            [FieldOffset(8)] // size = 4, padding = 0
            public sapp_event_type type;

            [FieldOffset(12)] // size = 4, padding = 0
            public sapp_keycode key_code;

            [FieldOffset(16)] // size = 4, padding = 0
            public uint char_code;

            [FieldOffset(20)] // size = 1, padding = 3
            public CBool key_repeat;

            [FieldOffset(24)] // size = 4, padding = 0
            public uint modifiers;

            [FieldOffset(28)] // size = 4, padding = 0
            public sapp_mousebutton mouse_button;

            [FieldOffset(32)] // size = 4, padding = 0
            public float mouse_x;

            [FieldOffset(36)] // size = 4, padding = 0
            public float mouse_y;

            [FieldOffset(40)] // size = 4, padding = 0
            public float mouse_dx;

            [FieldOffset(44)] // size = 4, padding = 0
            public float mouse_dy;

            [FieldOffset(48)] // size = 4, padding = 0
            public float scroll_x;

            [FieldOffset(52)] // size = 4, padding = 0
            public float scroll_y;

            [FieldOffset(56)] // size = 4, padding = 4
            public int num_touches;

            [FieldOffset(64)] // size = 192, padding = 0
            public fixed ulong _touches[192 / 8]; // sapp_touchpoint[8]

            public Span<sapp_touchpoint> touches
            {
                get
                {
                    fixed (sapp_event* @this = &this)
                    {
                        var pointer = &@this->_touches[0];
                        var span = new Span<sapp_touchpoint>(pointer, 8);
                        return span;
                    }
                }
            }

            [FieldOffset(256)] // size = 4, padding = 0
            public int window_width;

            [FieldOffset(260)] // size = 4, padding = 0
            public int window_height;

            [FieldOffset(264)] // size = 4, padding = 0
            public int framebuffer_width;

            [FieldOffset(268)] // size = 4, padding = 0
            public int framebuffer_height;
        }

        // Struct @ sokol_app.h:1334:3
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct sapp_image_desc
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int width;

            [FieldOffset(4)] // size = 4, padding = 0
            public int height;

            [FieldOffset(8)] // size = 16, padding = 0
            public sapp_range pixels;
        }

        // Struct @ sokol_app.h:1420:3
        [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 8)]
        public struct sapp_html5_fetch_response
        {
            [FieldOffset(0)] // size = 1, padding = 3
            public CBool succeeded;

            [FieldOffset(4)] // size = 4, padding = 0
            public sapp_html5_fetch_error error_code;

            [FieldOffset(8)] // size = 4, padding = 0
            public int file_index;

            [FieldOffset(12)] // size = 4, padding = 0
            public uint fetched_size;

            [FieldOffset(16)] // size = 8, padding = 0
            public void* buffer_ptr;

            [FieldOffset(24)] // size = 4, padding = 4
            public uint buffer_size;

            [FieldOffset(32)] // size = 8, padding = 0
            public void* user_data;
        }

        // Struct @ sokol_gfx.h:1888:3
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct sg_shader_attr_desc
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public CString name;

            [FieldOffset(8)] // size = 8, padding = 0
            public CString sem_name;

            [FieldOffset(16)] // size = 4, padding = 4
            public int sem_index;
        }

        // Struct @ sokol_gfx.h:2023:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 4)]
        public struct sg_stencil_face_state
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public sg_compare_func compare;

            [FieldOffset(4)] // size = 4, padding = 0
            public sg_stencil_op fail_op;

            [FieldOffset(8)] // size = 4, padding = 0
            public sg_stencil_op depth_fail_op;

            [FieldOffset(12)] // size = 4, padding = 0
            public sg_stencil_op pass_op;
        }

        // Struct @ sokol_gfx.h:2057:3
        [StructLayout(LayoutKind.Explicit, Size = 36, Pack = 4)]
        public struct sg_color_state
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public sg_pixel_format pixel_format;

            [FieldOffset(4)] // size = 4, padding = 0
            public sg_color_mask write_mask;

            [FieldOffset(8)] // size = 28, padding = 0
            public sg_blend_state blend;
        }

        // Struct @ sokol_gfx.h:1608:3
        [StructLayout(LayoutKind.Explicit, Size = 20, Pack = 4)]
        public struct sg_color_attachment_action
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public sg_action action;

            [FieldOffset(4)] // size = 16, padding = 0
            public Rgba32F value;
        }

        // Struct @ sokol_fetch.h:901:3
        [StructLayout(LayoutKind.Explicit, Size = 64, Pack = 8)]
        public struct sfetch_response_t
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public sfetch_handle_t handle;

            [FieldOffset(4)] // size = 1, padding = 0
            public CBool dispatched;

            [FieldOffset(5)] // size = 1, padding = 0
            public CBool fetched;

            [FieldOffset(6)] // size = 1, padding = 0
            public CBool paused;

            [FieldOffset(7)] // size = 1, padding = 0
            public CBool finished;

            [FieldOffset(8)] // size = 1, padding = 0
            public CBool failed;

            [FieldOffset(9)] // size = 1, padding = 2
            public CBool cancelled;

            [FieldOffset(12)] // size = 4, padding = 0
            public sfetch_error_t error_code;

            [FieldOffset(16)] // size = 4, padding = 0
            public uint channel;

            [FieldOffset(20)] // size = 4, padding = 0
            public uint lane;

            [FieldOffset(24)] // size = 8, padding = 0
            public CString path;

            [FieldOffset(32)] // size = 8, padding = 0
            public void* user_data;

            [FieldOffset(40)] // size = 4, padding = 0
            public uint fetched_offset;

            [FieldOffset(44)] // size = 4, padding = 0
            public uint fetched_size;

            [FieldOffset(48)] // size = 8, padding = 0
            public void* buffer_ptr;

            [FieldOffset(56)] // size = 4, padding = 4
            public uint buffer_size;
        }

        // Struct @ sokol_app.h:1307:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct sapp_range
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public void* ptr;

            [FieldOffset(8)] // size = 8, padding = 0
            public ulong size;
        }

        // Struct @ sokol_gfx.h:1900:3
        [StructLayout(LayoutKind.Explicit, Size = 272, Pack = 8)]
        public struct sg_shader_uniform_block_desc
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public ulong size;

            [FieldOffset(8)] // size = 4, padding = 4
            public sg_uniform_layout layout;

            [FieldOffset(16)] // size = 256, padding = 0
            public fixed ulong _uniforms[256 / 8]; // sg_shader_uniform_desc[16]

            public Span<sg_shader_uniform_desc> uniforms
            {
                get
                {
                    fixed (sg_shader_uniform_block_desc* @this = &this)
                    {
                        var pointer = &@this->_uniforms[0];
                        var span = new Span<sg_shader_uniform_desc>(pointer, 16);
                        return span;
                    }
                }
            }
        }

        // Struct @ sokol_gfx.h:1906:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct sg_shader_image_desc
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public CString name;

            [FieldOffset(8)] // size = 4, padding = 0
            public sg_image_type image_type;

            [FieldOffset(12)] // size = 4, padding = 0
            public sg_sampler_type sampler_type;
        }

        // Struct @ sokol_gfx.h:2002:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
        public struct sg_buffer_layout_desc
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int stride;

            [FieldOffset(4)] // size = 4, padding = 0
            public sg_vertex_step step_func;

            [FieldOffset(8)] // size = 4, padding = 0
            public int step_rate;
        }

        // Struct @ sokol_gfx.h:2011:3
        [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
        public struct sg_vertex_attr_desc
        {
            [FieldOffset(0)] // size = 4, padding = 0
            public int buffer_index;

            [FieldOffset(4)] // size = 4, padding = 0
            public int offset;

            [FieldOffset(8)] // size = 4, padding = 0
            public sg_vertex_format format;
        }

        // Struct @ sokol_gfx.h:2051:3
        [StructLayout(LayoutKind.Explicit, Size = 28, Pack = 4)]
        public struct sg_blend_state
        {
            [FieldOffset(0)] // size = 1, padding = 3
            public CBool enabled;

            [FieldOffset(4)] // size = 4, padding = 0
            public sg_blend_factor src_factor_rgb;

            [FieldOffset(8)] // size = 4, padding = 0
            public sg_blend_factor dst_factor_rgb;

            [FieldOffset(12)] // size = 4, padding = 0
            public sg_blend_op op_rgb;

            [FieldOffset(16)] // size = 4, padding = 0
            public sg_blend_factor src_factor_alpha;

            [FieldOffset(20)] // size = 4, padding = 0
            public sg_blend_factor dst_factor_alpha;

            [FieldOffset(24)] // size = 4, padding = 0
            public sg_blend_op op_alpha;
        }

        // Struct @ sokol_app.h:1238:3
        [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
        public struct sapp_touchpoint
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public UIntPtr identifier;

            [FieldOffset(8)] // size = 4, padding = 0
            public float pos_x;

            [FieldOffset(12)] // size = 4, padding = 0
            public float pos_y;

            [FieldOffset(16)] // size = 1, padding = 7
            public CBool changed;
        }

        // Struct @ sokol_gfx.h:1894:3
        [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
        public struct sg_shader_uniform_desc
        {
            [FieldOffset(0)] // size = 8, padding = 0
            public CString name;

            [FieldOffset(8)] // size = 4, padding = 0
            public sg_uniform_type type;

            [FieldOffset(12)] // size = 4, padding = 0
            public int array_count;
        }

        // Enum @ sokol_gfx.h:1156:3
        public enum sg_shader_stage : int
        {
            SG_SHADERSTAGE_VS = 0,
            SG_SHADERSTAGE_FS = 1,
            _SG_SHADERSTAGE_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:804:3
        public enum sg_backend : int
        {
            SG_BACKEND_GLCORE33 = 0,
            SG_BACKEND_GLES2 = 1,
            SG_BACKEND_GLES3 = 2,
            SG_BACKEND_D3D11 = 3,
            SG_BACKEND_METAL_IOS = 4,
            SG_BACKEND_METAL_MACOS = 5,
            SG_BACKEND_METAL_SIMULATOR = 6,
            SG_BACKEND_WGPU = 7,
            SG_BACKEND_DUMMY = 8
        }

        // Enum @ sokol_gfx.h:930:3
        public enum sg_pixel_format : int
        {
            _SG_PIXELFORMAT_DEFAULT = 0,
            SG_PIXELFORMAT_NONE = 1,
            SG_PIXELFORMAT_R8 = 2,
            SG_PIXELFORMAT_R8SN = 3,
            SG_PIXELFORMAT_R8UI = 4,
            SG_PIXELFORMAT_R8SI = 5,
            SG_PIXELFORMAT_R16 = 6,
            SG_PIXELFORMAT_R16SN = 7,
            SG_PIXELFORMAT_R16UI = 8,
            SG_PIXELFORMAT_R16SI = 9,
            SG_PIXELFORMAT_R16F = 10,
            SG_PIXELFORMAT_RG8 = 11,
            SG_PIXELFORMAT_RG8SN = 12,
            SG_PIXELFORMAT_RG8UI = 13,
            SG_PIXELFORMAT_RG8SI = 14,
            SG_PIXELFORMAT_R32UI = 15,
            SG_PIXELFORMAT_R32SI = 16,
            SG_PIXELFORMAT_R32F = 17,
            SG_PIXELFORMAT_RG16 = 18,
            SG_PIXELFORMAT_RG16SN = 19,
            SG_PIXELFORMAT_RG16UI = 20,
            SG_PIXELFORMAT_RG16SI = 21,
            SG_PIXELFORMAT_RG16F = 22,
            SG_PIXELFORMAT_RGBA8 = 23,
            SG_PIXELFORMAT_RGBA8SN = 24,
            SG_PIXELFORMAT_RGBA8UI = 25,
            SG_PIXELFORMAT_RGBA8SI = 26,
            SG_PIXELFORMAT_BGRA8 = 27,
            SG_PIXELFORMAT_RGB10A2 = 28,
            SG_PIXELFORMAT_RG11B10F = 29,
            SG_PIXELFORMAT_RG32UI = 30,
            SG_PIXELFORMAT_RG32SI = 31,
            SG_PIXELFORMAT_RG32F = 32,
            SG_PIXELFORMAT_RGBA16 = 33,
            SG_PIXELFORMAT_RGBA16SN = 34,
            SG_PIXELFORMAT_RGBA16UI = 35,
            SG_PIXELFORMAT_RGBA16SI = 36,
            SG_PIXELFORMAT_RGBA16F = 37,
            SG_PIXELFORMAT_RGBA32UI = 38,
            SG_PIXELFORMAT_RGBA32SI = 39,
            SG_PIXELFORMAT_RGBA32F = 40,
            SG_PIXELFORMAT_DEPTH = 41,
            SG_PIXELFORMAT_DEPTH_STENCIL = 42,
            SG_PIXELFORMAT_BC1_RGBA = 43,
            SG_PIXELFORMAT_BC2_RGBA = 44,
            SG_PIXELFORMAT_BC3_RGBA = 45,
            SG_PIXELFORMAT_BC4_R = 46,
            SG_PIXELFORMAT_BC4_RSN = 47,
            SG_PIXELFORMAT_BC5_RG = 48,
            SG_PIXELFORMAT_BC5_RGSN = 49,
            SG_PIXELFORMAT_BC6H_RGBF = 50,
            SG_PIXELFORMAT_BC6H_RGBUF = 51,
            SG_PIXELFORMAT_BC7_RGBA = 52,
            SG_PIXELFORMAT_PVRTC_RGB_2BPP = 53,
            SG_PIXELFORMAT_PVRTC_RGB_4BPP = 54,
            SG_PIXELFORMAT_PVRTC_RGBA_2BPP = 55,
            SG_PIXELFORMAT_PVRTC_RGBA_4BPP = 56,
            SG_PIXELFORMAT_ETC2_RGB8 = 57,
            SG_PIXELFORMAT_ETC2_RGB8A1 = 58,
            SG_PIXELFORMAT_ETC2_RGBA8 = 59,
            SG_PIXELFORMAT_ETC2_RG11 = 60,
            SG_PIXELFORMAT_ETC2_RG11SN = 61,
            _SG_PIXELFORMAT_NUM = 62,
            _SG_PIXELFORMAT_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1005:3
        public enum sg_resource_state : int
        {
            SG_RESOURCESTATE_INITIAL = 0,
            SG_RESOURCESTATE_ALLOC = 1,
            SG_RESOURCESTATE_VALID = 2,
            SG_RESOURCESTATE_FAILED = 3,
            SG_RESOURCESTATE_INVALID = 4,
            _SG_RESOURCESTATE_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1064:3
        public enum sg_buffer_type : int
        {
            _SG_BUFFERTYPE_DEFAULT = 0,
            SG_BUFFERTYPE_VERTEXBUFFER = 1,
            SG_BUFFERTYPE_INDEXBUFFER = 2,
            _SG_BUFFERTYPE_NUM = 3,
            _SG_BUFFERTYPE_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1048:3
        public enum sg_usage : int
        {
            _SG_USAGE_DEFAULT = 0,
            SG_USAGE_IMMUTABLE = 1,
            SG_USAGE_DYNAMIC = 2,
            SG_USAGE_STREAM = 3,
            _SG_USAGE_NUM = 4,
            _SG_USAGE_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1105:3
        public enum sg_image_type : int
        {
            _SG_IMAGETYPE_DEFAULT = 0,
            SG_IMAGETYPE_2D = 1,
            SG_IMAGETYPE_CUBE = 2,
            SG_IMAGETYPE_3D = 3,
            SG_IMAGETYPE_ARRAY = 4,
            _SG_IMAGETYPE_NUM = 5,
            _SG_IMAGETYPE_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1197:3
        public enum sg_filter : int
        {
            _SG_FILTER_DEFAULT = 0,
            SG_FILTER_NEAREST = 1,
            SG_FILTER_LINEAR = 2,
            SG_FILTER_NEAREST_MIPMAP_NEAREST = 3,
            SG_FILTER_NEAREST_MIPMAP_LINEAR = 4,
            SG_FILTER_LINEAR_MIPMAP_NEAREST = 5,
            SG_FILTER_LINEAR_MIPMAP_LINEAR = 6,
            _SG_FILTER_NUM = 7,
            _SG_FILTER_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1235:3
        public enum sg_wrap : int
        {
            _SG_WRAP_DEFAULT = 0,
            SG_WRAP_REPEAT = 1,
            SG_WRAP_CLAMP_TO_EDGE = 2,
            SG_WRAP_CLAMP_TO_BORDER = 3,
            SG_WRAP_MIRRORED_REPEAT = 4,
            _SG_WRAP_NUM = 5,
            _SG_WRAP_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1252:3
        public enum sg_border_color : int
        {
            _SG_BORDERCOLOR_DEFAULT = 0,
            SG_BORDERCOLOR_TRANSPARENT_BLACK = 1,
            SG_BORDERCOLOR_OPAQUE_BLACK = 2,
            SG_BORDERCOLOR_OPAQUE_WHITE = 3,
            _SG_BORDERCOLOR_NUM = 4,
            _SG_BORDERCOLOR_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1176:3
        public enum sg_primitive_type : int
        {
            _SG_PRIMITIVETYPE_DEFAULT = 0,
            SG_PRIMITIVETYPE_POINTS = 1,
            SG_PRIMITIVETYPE_LINES = 2,
            SG_PRIMITIVETYPE_LINE_STRIP = 3,
            SG_PRIMITIVETYPE_TRIANGLES = 4,
            SG_PRIMITIVETYPE_TRIANGLE_STRIP = 5,
            _SG_PRIMITIVETYPE_NUM = 6,
            _SG_PRIMITIVETYPE_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1083:3
        public enum sg_index_type : int
        {
            _SG_INDEXTYPE_DEFAULT = 0,
            SG_INDEXTYPE_NONE = 1,
            SG_INDEXTYPE_UINT16 = 2,
            SG_INDEXTYPE_UINT32 = 3,
            _SG_INDEXTYPE_NUM = 4,
            _SG_INDEXTYPE_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1380:3
        public enum sg_cull_mode : int
        {
            _SG_CULLMODE_DEFAULT = 0,
            SG_CULLMODE_NONE = 1,
            SG_CULLMODE_FRONT = 2,
            SG_CULLMODE_BACK = 3,
            _SG_CULLMODE_NUM = 4,
            _SG_CULLMODE_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1397:3
        public enum sg_face_winding : int
        {
            _SG_FACEWINDING_DEFAULT = 0,
            SG_FACEWINDING_CCW = 1,
            SG_FACEWINDING_CW = 2,
            _SG_FACEWINDING_NUM = 3,
            _SG_FACEWINDING_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1427:3
        public enum sg_compare_func : int
        {
            _SG_COMPAREFUNC_DEFAULT = 0,
            SG_COMPAREFUNC_NEVER = 1,
            SG_COMPAREFUNC_LESS = 2,
            SG_COMPAREFUNC_EQUAL = 3,
            SG_COMPAREFUNC_LESS_EQUAL = 4,
            SG_COMPAREFUNC_GREATER = 5,
            SG_COMPAREFUNC_NOT_EQUAL = 6,
            SG_COMPAREFUNC_GREATER_EQUAL = 7,
            SG_COMPAREFUNC_ALWAYS = 8,
            _SG_COMPAREFUNC_NUM = 9,
            _SG_COMPAREFUNC_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1584:3
        public enum sg_action : int
        {
            _SG_ACTION_DEFAULT = 0,
            SG_ACTION_CLEAR = 1,
            SG_ACTION_LOAD = 2,
            SG_ACTION_DONTCARE = 3,
            _SG_ACTION_NUM = 4,
            _SG_ACTION_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_app.h:1090:3
        public enum sapp_event_type : int
        {
            SAPP_EVENTTYPE_INVALID = 0,
            SAPP_EVENTTYPE_KEY_DOWN = 1,
            SAPP_EVENTTYPE_KEY_UP = 2,
            SAPP_EVENTTYPE_CHAR = 3,
            SAPP_EVENTTYPE_MOUSE_DOWN = 4,
            SAPP_EVENTTYPE_MOUSE_UP = 5,
            SAPP_EVENTTYPE_MOUSE_SCROLL = 6,
            SAPP_EVENTTYPE_MOUSE_MOVE = 7,
            SAPP_EVENTTYPE_MOUSE_ENTER = 8,
            SAPP_EVENTTYPE_MOUSE_LEAVE = 9,
            SAPP_EVENTTYPE_TOUCHES_BEGAN = 10,
            SAPP_EVENTTYPE_TOUCHES_MOVED = 11,
            SAPP_EVENTTYPE_TOUCHES_ENDED = 12,
            SAPP_EVENTTYPE_TOUCHES_CANCELLED = 13,
            SAPP_EVENTTYPE_RESIZED = 14,
            SAPP_EVENTTYPE_ICONIFIED = 15,
            SAPP_EVENTTYPE_RESTORED = 16,
            SAPP_EVENTTYPE_FOCUSED = 17,
            SAPP_EVENTTYPE_UNFOCUSED = 18,
            SAPP_EVENTTYPE_SUSPENDED = 19,
            SAPP_EVENTTYPE_RESUMED = 20,
            SAPP_EVENTTYPE_UPDATE_CURSOR = 21,
            SAPP_EVENTTYPE_QUIT_REQUESTED = 22,
            SAPP_EVENTTYPE_CLIPBOARD_PASTED = 23,
            SAPP_EVENTTYPE_FILES_DROPPED = 24,
            _SAPP_EVENTTYPE_NUM = 25,
            _SAPP_EVENTTYPE_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_app.h:1222:3
        public enum sapp_keycode : int
        {
            SAPP_KEYCODE_INVALID = 0,
            SAPP_KEYCODE_SPACE = 32,
            SAPP_KEYCODE_APOSTROPHE = 39,
            SAPP_KEYCODE_COMMA = 44,
            SAPP_KEYCODE_MINUS = 45,
            SAPP_KEYCODE_PERIOD = 46,
            SAPP_KEYCODE_SLASH = 47,
            SAPP_KEYCODE_0 = 48,
            SAPP_KEYCODE_1 = 49,
            SAPP_KEYCODE_2 = 50,
            SAPP_KEYCODE_3 = 51,
            SAPP_KEYCODE_4 = 52,
            SAPP_KEYCODE_5 = 53,
            SAPP_KEYCODE_6 = 54,
            SAPP_KEYCODE_7 = 55,
            SAPP_KEYCODE_8 = 56,
            SAPP_KEYCODE_9 = 57,
            SAPP_KEYCODE_SEMICOLON = 59,
            SAPP_KEYCODE_EQUAL = 61,
            SAPP_KEYCODE_A = 65,
            SAPP_KEYCODE_B = 66,
            SAPP_KEYCODE_C = 67,
            SAPP_KEYCODE_D = 68,
            SAPP_KEYCODE_E = 69,
            SAPP_KEYCODE_F = 70,
            SAPP_KEYCODE_G = 71,
            SAPP_KEYCODE_H = 72,
            SAPP_KEYCODE_I = 73,
            SAPP_KEYCODE_J = 74,
            SAPP_KEYCODE_K = 75,
            SAPP_KEYCODE_L = 76,
            SAPP_KEYCODE_M = 77,
            SAPP_KEYCODE_N = 78,
            SAPP_KEYCODE_O = 79,
            SAPP_KEYCODE_P = 80,
            SAPP_KEYCODE_Q = 81,
            SAPP_KEYCODE_R = 82,
            SAPP_KEYCODE_S = 83,
            SAPP_KEYCODE_T = 84,
            SAPP_KEYCODE_U = 85,
            SAPP_KEYCODE_V = 86,
            SAPP_KEYCODE_W = 87,
            SAPP_KEYCODE_X = 88,
            SAPP_KEYCODE_Y = 89,
            SAPP_KEYCODE_Z = 90,
            SAPP_KEYCODE_LEFT_BRACKET = 91,
            SAPP_KEYCODE_BACKSLASH = 92,
            SAPP_KEYCODE_RIGHT_BRACKET = 93,
            SAPP_KEYCODE_GRAVE_ACCENT = 96,
            SAPP_KEYCODE_WORLD_1 = 161,
            SAPP_KEYCODE_WORLD_2 = 162,
            SAPP_KEYCODE_ESCAPE = 256,
            SAPP_KEYCODE_ENTER = 257,
            SAPP_KEYCODE_TAB = 258,
            SAPP_KEYCODE_BACKSPACE = 259,
            SAPP_KEYCODE_INSERT = 260,
            SAPP_KEYCODE_DELETE = 261,
            SAPP_KEYCODE_RIGHT = 262,
            SAPP_KEYCODE_LEFT = 263,
            SAPP_KEYCODE_DOWN = 264,
            SAPP_KEYCODE_UP = 265,
            SAPP_KEYCODE_PAGE_UP = 266,
            SAPP_KEYCODE_PAGE_DOWN = 267,
            SAPP_KEYCODE_HOME = 268,
            SAPP_KEYCODE_END = 269,
            SAPP_KEYCODE_CAPS_LOCK = 280,
            SAPP_KEYCODE_SCROLL_LOCK = 281,
            SAPP_KEYCODE_NUM_LOCK = 282,
            SAPP_KEYCODE_PRINT_SCREEN = 283,
            SAPP_KEYCODE_PAUSE = 284,
            SAPP_KEYCODE_F1 = 290,
            SAPP_KEYCODE_F2 = 291,
            SAPP_KEYCODE_F3 = 292,
            SAPP_KEYCODE_F4 = 293,
            SAPP_KEYCODE_F5 = 294,
            SAPP_KEYCODE_F6 = 295,
            SAPP_KEYCODE_F7 = 296,
            SAPP_KEYCODE_F8 = 297,
            SAPP_KEYCODE_F9 = 298,
            SAPP_KEYCODE_F10 = 299,
            SAPP_KEYCODE_F11 = 300,
            SAPP_KEYCODE_F12 = 301,
            SAPP_KEYCODE_F13 = 302,
            SAPP_KEYCODE_F14 = 303,
            SAPP_KEYCODE_F15 = 304,
            SAPP_KEYCODE_F16 = 305,
            SAPP_KEYCODE_F17 = 306,
            SAPP_KEYCODE_F18 = 307,
            SAPP_KEYCODE_F19 = 308,
            SAPP_KEYCODE_F20 = 309,
            SAPP_KEYCODE_F21 = 310,
            SAPP_KEYCODE_F22 = 311,
            SAPP_KEYCODE_F23 = 312,
            SAPP_KEYCODE_F24 = 313,
            SAPP_KEYCODE_F25 = 314,
            SAPP_KEYCODE_KP_0 = 320,
            SAPP_KEYCODE_KP_1 = 321,
            SAPP_KEYCODE_KP_2 = 322,
            SAPP_KEYCODE_KP_3 = 323,
            SAPP_KEYCODE_KP_4 = 324,
            SAPP_KEYCODE_KP_5 = 325,
            SAPP_KEYCODE_KP_6 = 326,
            SAPP_KEYCODE_KP_7 = 327,
            SAPP_KEYCODE_KP_8 = 328,
            SAPP_KEYCODE_KP_9 = 329,
            SAPP_KEYCODE_KP_DECIMAL = 330,
            SAPP_KEYCODE_KP_DIVIDE = 331,
            SAPP_KEYCODE_KP_MULTIPLY = 332,
            SAPP_KEYCODE_KP_SUBTRACT = 333,
            SAPP_KEYCODE_KP_ADD = 334,
            SAPP_KEYCODE_KP_ENTER = 335,
            SAPP_KEYCODE_KP_EQUAL = 336,
            SAPP_KEYCODE_LEFT_SHIFT = 340,
            SAPP_KEYCODE_LEFT_CONTROL = 341,
            SAPP_KEYCODE_LEFT_ALT = 342,
            SAPP_KEYCODE_LEFT_SUPER = 343,
            SAPP_KEYCODE_RIGHT_SHIFT = 344,
            SAPP_KEYCODE_RIGHT_CONTROL = 345,
            SAPP_KEYCODE_RIGHT_ALT = 346,
            SAPP_KEYCODE_RIGHT_SUPER = 347,
            SAPP_KEYCODE_MENU = 348
        }

        // Enum @ sokol_app.h:1251:3
        public enum sapp_mousebutton : int
        {
            SAPP_MOUSEBUTTON_LEFT = 0,
            SAPP_MOUSEBUTTON_RIGHT = 1,
            SAPP_MOUSEBUTTON_MIDDLE = 2,
            SAPP_MOUSEBUTTON_INVALID = 256
        }

        // Enum @ sokol_app.h:1410:3
        public enum sapp_html5_fetch_error : int
        {
            SAPP_HTML5_FETCH_ERROR_NO_ERROR = 0,
            SAPP_HTML5_FETCH_ERROR_BUFFER_TOO_SMALL = 1,
            SAPP_HTML5_FETCH_ERROR_OTHER = 2
        }

        // Enum @ sokol_gfx.h:1461:3
        public enum sg_stencil_op : int
        {
            _SG_STENCILOP_DEFAULT = 0,
            SG_STENCILOP_KEEP = 1,
            SG_STENCILOP_ZERO = 2,
            SG_STENCILOP_REPLACE = 3,
            SG_STENCILOP_INCR_CLAMP = 4,
            SG_STENCILOP_DECR_CLAMP = 5,
            SG_STENCILOP_INVERT = 6,
            SG_STENCILOP_INCR_WRAP = 7,
            SG_STENCILOP_DECR_WRAP = 8,
            _SG_STENCILOP_NUM = 9,
            _SG_STENCILOP_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1557:3
        public enum sg_color_mask : int
        {
            _SG_COLORMASK_DEFAULT = 0,
            SG_COLORMASK_NONE = 16,
            SG_COLORMASK_R = 1,
            SG_COLORMASK_G = 2,
            SG_COLORMASK_RG = 3,
            SG_COLORMASK_B = 4,
            SG_COLORMASK_RB = 5,
            SG_COLORMASK_GB = 6,
            SG_COLORMASK_RGB = 7,
            SG_COLORMASK_A = 8,
            SG_COLORMASK_RA = 9,
            SG_COLORMASK_GA = 10,
            SG_COLORMASK_RGA = 11,
            SG_COLORMASK_BA = 12,
            SG_COLORMASK_RBA = 13,
            SG_COLORMASK_GBA = 14,
            SG_COLORMASK_RGBA = 15,
            _SG_COLORMASK_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_fetch.h:881:3
        public enum sfetch_error_t : int
        {
            SFETCH_ERROR_NO_ERROR = 0,
            SFETCH_ERROR_FILE_NOT_FOUND = 1,
            SFETCH_ERROR_NO_BUFFER = 2,
            SFETCH_ERROR_BUFFER_TOO_SMALL = 3,
            SFETCH_ERROR_UNEXPECTED_EOF = 4,
            SFETCH_ERROR_INVALID_HTTP_STATUS = 5,
            SFETCH_ERROR_CANCELLED = 6
        }

        // Enum @ sokol_gfx.h:1362:3
        public enum sg_uniform_layout : int
        {
            _SG_UNIFORMLAYOUT_DEFAULT = 0,
            SG_UNIFORMLAYOUT_NATIVE = 1,
            SG_UNIFORMLAYOUT_STD140 = 2,
            _SG_UNIFORMLAYOUT_NUM = 3,
            _SG_UNIFORMLAYOUT_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1122:3
        public enum sg_sampler_type : int
        {
            _SG_SAMPLERTYPE_DEFAULT = 0,
            SG_SAMPLERTYPE_FLOAT = 1,
            SG_SAMPLERTYPE_SINT = 2,
            SG_SAMPLERTYPE_UINT = 3
        }

        // Enum @ sokol_gfx.h:1298:3
        public enum sg_vertex_step : int
        {
            _SG_VERTEXSTEP_DEFAULT = 0,
            SG_VERTEXSTEP_PER_VERTEX = 1,
            SG_VERTEXSTEP_PER_INSTANCE = 2,
            _SG_VERTEXSTEP_NUM = 3,
            _SG_VERTEXSTEP_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1279:3
        public enum sg_vertex_format : int
        {
            SG_VERTEXFORMAT_INVALID = 0,
            SG_VERTEXFORMAT_FLOAT = 1,
            SG_VERTEXFORMAT_FLOAT2 = 2,
            SG_VERTEXFORMAT_FLOAT3 = 3,
            SG_VERTEXFORMAT_FLOAT4 = 4,
            SG_VERTEXFORMAT_BYTE4 = 5,
            SG_VERTEXFORMAT_BYTE4N = 6,
            SG_VERTEXFORMAT_UBYTE4 = 7,
            SG_VERTEXFORMAT_UBYTE4N = 8,
            SG_VERTEXFORMAT_SHORT2 = 9,
            SG_VERTEXFORMAT_SHORT2N = 10,
            SG_VERTEXFORMAT_USHORT2N = 11,
            SG_VERTEXFORMAT_SHORT4 = 12,
            SG_VERTEXFORMAT_SHORT4N = 13,
            SG_VERTEXFORMAT_USHORT4N = 14,
            SG_VERTEXFORMAT_UINT10_N2 = 15,
            _SG_VERTEXFORMAT_NUM = 16,
            _SG_VERTEXFORMAT_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1499:3
        public enum sg_blend_factor : int
        {
            _SG_BLENDFACTOR_DEFAULT = 0,
            SG_BLENDFACTOR_ZERO = 1,
            SG_BLENDFACTOR_ONE = 2,
            SG_BLENDFACTOR_SRC_COLOR = 3,
            SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4,
            SG_BLENDFACTOR_SRC_ALPHA = 5,
            SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6,
            SG_BLENDFACTOR_DST_COLOR = 7,
            SG_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8,
            SG_BLENDFACTOR_DST_ALPHA = 9,
            SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10,
            SG_BLENDFACTOR_SRC_ALPHA_SATURATED = 11,
            SG_BLENDFACTOR_BLEND_COLOR = 12,
            SG_BLENDFACTOR_ONE_MINUS_BLEND_COLOR = 13,
            SG_BLENDFACTOR_BLEND_ALPHA = 14,
            SG_BLENDFACTOR_ONE_MINUS_BLEND_ALPHA = 15,
            _SG_BLENDFACTOR_NUM = 16,
            _SG_BLENDFACTOR_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1523:3
        public enum sg_blend_op : int
        {
            _SG_BLENDOP_DEFAULT = 0,
            SG_BLENDOP_ADD = 1,
            SG_BLENDOP_SUBTRACT = 2,
            SG_BLENDOP_REVERSE_SUBTRACT = 3,
            _SG_BLENDOP_NUM = 4,
            _SG_BLENDOP_FORCE_U32 = 2147483647
        }

        // Enum @ sokol_gfx.h:1320:3
        public enum sg_uniform_type : int
        {
            SG_UNIFORMTYPE_INVALID = 0,
            SG_UNIFORMTYPE_FLOAT = 1,
            SG_UNIFORMTYPE_FLOAT2 = 2,
            SG_UNIFORMTYPE_FLOAT3 = 3,
            SG_UNIFORMTYPE_FLOAT4 = 4,
            SG_UNIFORMTYPE_INT = 5,
            SG_UNIFORMTYPE_INT2 = 6,
            SG_UNIFORMTYPE_INT3 = 7,
            SG_UNIFORMTYPE_INT4 = 8,
            SG_UNIFORMTYPE_MAT4 = 9,
            _SG_UNIFORMTYPE_NUM = 10,
            _SG_UNIFORMTYPE_FORCE_U32 = 2147483647
        }

        // Pseudo enum 'sg_cube_face' @ sokol_gfx.h:1130:14
        public const int SG_CUBEFACE_POS_X = 0;
        public const int SG_CUBEFACE_NEG_X = 1;
        public const int SG_CUBEFACE_POS_Y = 2;
        public const int SG_CUBEFACE_NEG_Y = 3;
        public const int SG_CUBEFACE_POS_Z = 4;
        public const int SG_CUBEFACE_NEG_Z = 5;
        public const int SG_CUBEFACE_NUM = 6;
        public const int _SG_CUBEFACE_FORCE_U32 = 2147483647;

        // MacroDefinition @ sokol_app.h:1024:9
        public const int SOKOL_APP_INCLUDED = 1;

        // MacroDefinition @ sokol_gfx.h:686:9
        public const int SOKOL_GFX_INCLUDED = 1;

        // MacroDefinition @ sokol_audio.h:394:9
        public const int SOKOL_AUDIO_INCLUDED = 1;

        // MacroDefinition @ sokol_fetch.h:839:9
        public const int SOKOL_FETCH_INCLUDED = 1;

        // MacroDefinition @ sokol_time.h:108:9
        public const int SOKOL_TIME_INCLUDED = 1;

        // MacroDefinition @ sokol_args.h:251:9
        public const int SOKOL_ARGS_INCLUDED = 1;

        #region C2CS.Runtime

        public static class Runtime
        {

            /// <summary>
            ///     A boolean value type with the same memory layout as a <see cref="byte" /> in both managed and unmanaged contexts;
            ///     equivalent to a standard bool found in C/C++/ObjC where <c>0</c> is <c>false</c> and any other value is
            ///     <c>true</c>.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CBool : IEquatable<CBool>
            {
                private readonly byte _value;

                private CBool(bool value)
                {
                    _value = Convert.ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CBool" />.</returns>
                public static implicit operator CBool(bool value)
                {
                    return FromBoolean(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="bool" /> to a <see cref="CBool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CBool" />.</returns>
                public static CBool FromBoolean(bool value)
                {
                    return new CBool(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="bool" />.</returns>
                public static implicit operator bool(CBool value)
                {
                    return ToBoolean(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CBool" /> to a <see cref="bool" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="bool" />.</returns>
                public static bool ToBoolean(CBool value)
                {
                    return Convert.ToBoolean(value._value);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return ToBoolean(this).ToString();
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CBool b && Equals(b);
                }

                /// <inheritdoc />
                public bool Equals(CBool other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CBool left, CBool right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CBool left, CBool right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CBool" /> to compare.</param>
                /// <param name="right">The second <see cref="CBool" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CBool left, CBool right)
                {
                    return left._value == right._value;
                }
            }

            /// <summary>
            ///     A value type with the same memory layout as a <see cref="byte" /> in a managed context and <c>char</c> in
            ///     an unmanaged context.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CChar : IEquatable<byte>, IEquatable<CChar>
            {
                private readonly byte _value;

                private CChar(byte value)
                {
                    _value = Convert.ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CChar" />.</returns>
                public static implicit operator CChar(byte value)
                {
                    return FromByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="byte" /> to a <see cref="CChar" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="CChar" />.</returns>
                public static CChar FromByte(byte value)
                {
                    return new CChar(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="byte" />.</returns>
                public static implicit operator byte(CChar value)
                {
                    return ToByte(value);
                }

                /// <summary>
                ///     Converts the specified <see cref="CChar" /> to a <see cref="byte" />.
                /// </summary>
                /// <param name="value">The value.</param>
                /// <returns>A <see cref="byte" />.</returns>
                public static byte ToByte(CChar value)
                {
                    return value._value;
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return _value.ToString(CultureInfo.InvariantCulture);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CChar value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(byte other)
                {
                    return _value == other;
                }

                /// <inheritdoc />
                public bool Equals(CChar other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CChar left, CChar right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CChar left, CChar right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CChar" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CChar" /> to compare.</param>
                /// <param name="right">The second <see cref="CChar" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CChar left, CChar right)
                {
                    return left._value == right._value;
                }
            }

            /// <summary>
            ///     A value type with the memory layout of a <c>wchar_t</c> in an unmanaged context. The memory layout in a
            ///     managed context depends on the operating system or otherwise on preprocessor directives defines.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly struct CCharWide : IEquatable<CCharWide>
            {
#if SIZEOF_WCHAR_T_1
    private readonly byte _value;
#elif SIZEOF_WCHAR_T_2
    private readonly ushort _value;
#elif SIZEOF_WCHAR_T_4
    private readonly uint _value;
#else
                private readonly ushort _value;
#endif

                private CCharWide(byte value)
                {
#if SIZEOF_WCHAR_T_1
        _value = Convert.ToByte(value);
#elif SIZEOF_WCHAR_T_2
        _value = Convert.ToUInt16(value);
#elif SIZEOF_WCHAR_T_4
        _value = Convert.ToUInt32(value);
#else
                    _value = Convert.ToUInt16(value);
#endif
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return _value.ToString(CultureInfo.InvariantCulture);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CCharWide value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CCharWide other)
                {
                    return _value == other._value;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _value.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CCharWide left, CCharWide right)
                {
                    return left._value == right._value;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CCharWide left, CCharWide right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CCharWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CCharWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CCharWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CCharWide left, CCharWide right)
                {
                    return left._value == right._value;
                }
            }

            /// <summary>
            ///     A pointer value type of bytes that represent a string; the C type `char*`.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly unsafe struct CString : IEquatable<CString>
            {
                internal readonly nint _pointer;

                /// <summary>
                ///     Gets a value indicating whether this <see cref="CString" /> is a null pointer.
                /// </summary>
                public bool IsNull => _pointer == 0;

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CString(byte* value)
                {
                    _pointer = (nint)value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CString(nint value)
                {
                    _pointer = value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CString" /> struct.
                /// </summary>
                /// <param name="s">The string value.</param>
                public CString(string s)
                {
                    _pointer = CStrings.CString(s);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static explicit operator CString(nint value)
                {
                    return FromIntPtr(value);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString FromIntPtr(nint value)
                {
                    return new CString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static implicit operator CString(byte* value)
                {
                    return From(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CString" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString From(byte* value)
                {
                    return new CString((nint)value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static implicit operator nint(CString value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static nint ToIntPtr(CString value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CString" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static implicit operator string(CString value)
                {
                    return ToString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CString" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CString" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static string ToString(CString value)
                {
                    return CStrings.String(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static implicit operator CString(string s)
                {
                    return FromString(s);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CString" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CString" />.
                /// </returns>
                public static CString FromString(string s)
                {
                    return CStrings.CString(s);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return CStrings.String(this);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CString value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CString other)
                {
                    return _pointer == other._pointer;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _pointer.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CString left, CString right)
                {
                    return left._pointer == right._pointer;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CString left, CString right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CString" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CString" /> to compare.</param>
                /// <param name="right">The second <see cref="CString" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CString left, CString right)
                {
                    return left._pointer == right._pointer;
                }
            }

            /// <summary>
            ///     The collection of utility methods for interoperability with C style strings in C#.
            /// </summary>
            public static unsafe class CStrings
            {
                private static readonly Dictionary<uint, CString> StringHashesToPointers = new();
                private static readonly Dictionary<nint, string> PointersToStrings = new();
                private static readonly Dictionary<uint, CStringWide> StringHashesToPointersWide = new();
                private static readonly Dictionary<nint, string> PointersToStringsWide = new();

                /// <summary>
                ///     Converts a C style string (ANSI or UTF-8) of type `char` (one dimensional byte array
                ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="value">A pointer to the C string.</param>
                /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
                public static string String(CString value)
                {
                    if (value.IsNull)
                    {
                        return string.Empty;
                    }

                    if (PointersToStrings.TryGetValue(value._pointer, out var result))
                    {
                        return result;
                    }

                    var hash = Djb2((byte*)value._pointer);
                    if (StringHashesToPointers.TryGetValue(hash, out var pointer2))
                    {
                        result = PointersToStrings[pointer2._pointer];
                        return result;
                    }

                    // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                    // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                    result = Marshal.PtrToStringAnsi(value._pointer);

                    if (string.IsNullOrEmpty(result))
                    {
                        return string.Empty;
                    }

                    StringHashesToPointers.Add(hash, value);
                    PointersToStrings.Add(value._pointer, result);

                    return result;
                }

                /// <summary>
                ///     Converts a C style string (unicode) of type `wchar_t` (one dimensional ushort array
                ///     terminated by a <c>0x0</c>) to a UTF-16 <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="value">A pointer to the C string.</param>
                /// <returns>A <see cref="string" /> equivalent of <paramref name="value" />.</returns>
                public static string StringWide(CStringWide value)
                {
                    if (value.IsNull)
                    {
                        return string.Empty;
                    }

                    if (PointersToStringsWide.TryGetValue(value._pointer, out var result))
                    {
                        return result;
                    }

                    var hash = Djb2((byte*)value._pointer);
                    if (StringHashesToPointersWide.TryGetValue(hash, out var pointer2))
                    {
                        result = PointersToStringsWide[pointer2._pointer];
                        return result;
                    }

                    // calls ASM/C/C++ functions to calculate length and then "FastAllocate" the string with the GC
                    // https://mattwarren.org/2016/05/31/Strings-and-the-CLR-a-Special-Relationship/
                    result = Marshal.PtrToStringUni(pointer2._pointer);

                    if (string.IsNullOrEmpty(result))
                    {
                        return string.Empty;
                    }

                    StringHashesToPointersWide.Add(hash, value);
                    PointersToStringsWide.Add(value._pointer, result);

                    return result;
                }

                /// <summary>
                ///     Converts a UTF-16 <see cref="string" /> to a C style string (one dimensional byte array terminated by a
                ///     <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <param name="str">The <see cref="string" />.</param>
                /// <returns>A C string pointer.</returns>
                public static CString CString(string str)
                {
                    var hash = Djb2(str);
                    if (StringHashesToPointers.TryGetValue(hash, out var r))
                    {
                        return r;
                    }

                    // ReSharper disable once JoinDeclarationAndInitializer
                    var pointer = Marshal.StringToHGlobalAnsi(str);
                    StringHashesToPointers.Add(hash, new CString(pointer));
                    PointersToStrings.Add(pointer, str);

                    return new CString(pointer);
                }

                /// <summary>
                ///     Converts a C string pointer (one dimensional byte array terminated by a
                ///     <c>0x0</c>) for a specified <see cref="string" /> by allocating and copying if not already cached.
                /// </summary>
                /// <param name="str">The <see cref="string" />.</param>
                /// <returns>A C string pointer.</returns>
                public static CStringWide CStringWide(string str)
                {
                    var hash = Djb2(str);
                    if (StringHashesToPointersWide.TryGetValue(hash, out var r))
                    {
                        return r;
                    }

                    // ReSharper disable once JoinDeclarationAndInitializer
                    var pointer = Marshal.StringToHGlobalUni(str);
                    StringHashesToPointersWide.Add(hash, new CStringWide(pointer));
                    PointersToStringsWide.Add(pointer, str);

                    return new CStringWide(pointer);
                }

                /// <summary>
                ///     Converts an array of strings to an array of C strings of type `char` (multi-dimensional array of one
                ///     dimensional byte arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <remarks>
                ///     <para>Calls <see cref="CString" />.</para>
                /// </remarks>
                /// <param name="values">The strings.</param>
                /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
                public static CString* CStringArray(ReadOnlySpan<string> values)
                {
                    var pointerSize = IntPtr.Size;
                    var result = (CString*)Marshal.AllocHGlobal(pointerSize * values.Length);
                    for (var i = 0; i < values.Length; ++i)
                    {
                        var @string = values[i];
                        var cString = CString(@string);
                        result[i] = cString;
                    }

                    return result;
                }

                /// <summary>
                ///     Converts an array of strings to an array of C strings of type `wchar_t` (multi-dimensional array of one
                ///     dimensional ushort arrays each terminated by a <c>0x0</c>) by allocating and copying if not already cached.
                /// </summary>
                /// <remarks>
                ///     <para>Calls <see cref="CString" />.</para>
                /// </remarks>
                /// <param name="values">The strings.</param>
                /// <returns>An array pointer of C string pointers. You are responsible for freeing the returned pointer.</returns>
                public static CStringWide* CStringWideArray(ReadOnlySpan<string> values)
                {
                    var pointerSize = IntPtr.Size;
                    var result = (CStringWide*)Marshal.AllocHGlobal(pointerSize * values.Length);
                    for (var i = 0; i < values.Length; ++i)
                    {
                        var @string = values[i];
                        var cString = CStringWide(@string);
                        result[i] = cString;
                    }

                    return result;
                }

                /// <summary>
                ///     Frees the memory for all previously allocated C strings and releases references to all <see cref="string" />
                ///     objects which happened during <see cref="String" />, <see cref="StringWide" />, <see cref="CString" />
                ///     or <see cref="CStringWide" />. Does <b>not</b> garbage collect.
                /// </summary>
                public static void FreeAllStrings()
                {
                    foreach (var (ptr, _) in PointersToStrings)
                    {
                        Marshal.FreeHGlobal(ptr);
                    }

                    // We can not guarantee that the application has not a strong reference the string since it was allocated,
                    //  so we have to let the GC take the wheel here. Thus, this method should NOT garbage collect; that's
                    //  on the responsibility of the application developer. The best we can do is just remove any and all strong
                    //  references we have here to the strings.

                    StringHashesToPointers.Clear();
                    PointersToStrings.Clear();
                }

                /// <summary>
                ///     Frees the memory for specific previously allocated C strings and releases associated references to
                ///     <see cref="string" /> objects which happened during <see cref="String" /> or
                ///     <see cref="CString" />. Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="pointers">The C string pointers.</param>
                /// <param name="count">The number of C string pointers.</param>
                public static void FreeCStrings(CString* pointers, int count)
                {
                    for (var i = 0; i < count; i++)
                    {
                        var ptr = pointers[i];
                        FreeCString(ptr);
                    }

                    Marshal.FreeHGlobal((IntPtr)pointers);
                }

                /// <summary>
                ///     Frees the memory for the previously allocated C string and releases reference to the
                ///     <see cref="string" /> object which happened during <see cref="String" /> or <see cref="CString" />.
                ///     Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="value">The string.</param>
                public static void FreeCString(CString value)
                {
                    if (!PointersToStrings.ContainsKey(value._pointer))
                    {
                        return;
                    }

                    Marshal.FreeHGlobal(value);
                    var hash = Djb2(value);
                    StringHashesToPointers.Remove(hash);
                    PointersToStrings.Remove(value._pointer);
                }

                /// <summary>
                ///     Frees the memory for the previously allocated C string and releases reference to the
                ///     <see cref="string" /> object which happened during <see cref="StringWide" /> or <see cref="CStringWide" />.
                ///     Does <b>not</b> garbage collect.
                /// </summary>
                /// <param name="value">The string.</param>
                public static void FreeCStringWide(CStringWide value)
                {
                    if (!PointersToStringsWide.ContainsKey(value._pointer))
                    {
                        return;
                    }

                    Marshal.FreeHGlobal(value);
                    var hash = Djb2(value);
                    StringHashesToPointersWide.Remove(hash);
                    PointersToStringsWide.Remove(value._pointer);
                }

                // djb2 is named after https://en.wikipedia.org/wiki/Daniel_J._Bernstein
                //  References:
                //  (1) https://stackoverflow.com/a/7666577/2171957
                //  (2) http://www.cse.yorku.ca/~oz/hash.html
                //  (3) https://groups.google.com/g/comp.lang.c/c/lSKWXiuNOAk/m/zstZ3SRhCjgJ
                private static uint Djb2(byte* str)
                {
                    uint hash = 5381;

                    unchecked
                    {
                        uint c;
                        while ((c = *str++) != 0)
                        {
                            hash = (hash << 5) + hash + c; // hash * 33 + c
                        }
                    }

                    return hash;
                }

                private static uint Djb2(string str)
                {
                    uint hash = 5381;

                    // ReSharper disable once ForeachCanBeConvertedToQueryUsingAnotherGetEnumerator
                    foreach (var c in str)
                    {
                        hash = (hash << 5) + hash + c; // hash * 33 + c
                    }

                    return hash;
                }
            }

            /// <summary>
            ///     A pointer value type that represents a wide string; C type `wchar_t*`.
            /// </summary>
            [StructLayout(LayoutKind.Sequential)]
            public readonly unsafe struct CStringWide : IEquatable<CStringWide>
            {
                internal readonly nint _pointer;

                /// <summary>
                ///     Gets a value indicating whether this <see cref="CStringWide" /> is a null pointer.
                /// </summary>
                public bool IsNull => _pointer == 0;

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CStringWide(byte* value)
                {
                    _pointer = (nint)value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                public CStringWide(nint value)
                {
                    _pointer = value;
                }

                /// <summary>
                ///     Initializes a new instance of the <see cref="CStringWide" /> struct.
                /// </summary>
                /// <param name="s">The string value.</param>
                public CStringWide(string s)
                {
                    _pointer = CStrings.CStringWide(s);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static explicit operator CStringWide(nint value)
                {
                    return FromIntPtr(value);
                }

                /// <summary>
                ///     Performs an explicit conversion from a <see cref="IntPtr" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide FromIntPtr(nint value)
                {
                    return new CStringWide(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static implicit operator CStringWide(byte* value)
                {
                    return From(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a byte pointer to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="value">The pointer value.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide From(byte* value)
                {
                    return new CStringWide((nint)value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static implicit operator nint(CStringWide value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="IntPtr" />.
                /// </summary>
                /// <param name="value">The pointer.</param>
                /// <returns>
                ///     The resulting <see cref="IntPtr" />.
                /// </returns>
                public static nint ToIntPtr(CStringWide value)
                {
                    return value._pointer;
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CStringWide" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static implicit operator string(CStringWide value)
                {
                    return ToString(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="CStringWide" /> to a <see cref="string" />.
                /// </summary>
                /// <param name="value">The <see cref="CStringWide" />.</param>
                /// <returns>
                ///     The resulting <see cref="string" />.
                /// </returns>
                public static string ToString(CStringWide value)
                {
                    return CStrings.StringWide(value);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static implicit operator CStringWide(string s)
                {
                    return FromString(s);
                }

                /// <summary>
                ///     Performs an implicit conversion from a <see cref="string" /> to a <see cref="CStringWide" />.
                /// </summary>
                /// <param name="s">The <see cref="string" />.</param>
                /// <returns>
                ///     The resulting <see cref="CStringWide" />.
                /// </returns>
                public static CStringWide FromString(string s)
                {
                    return CStrings.CStringWide(s);
                }

                /// <inheritdoc />
                public override string ToString()
                {
                    return CStrings.StringWide(this);
                }

                /// <inheritdoc />
                public override bool Equals(object? obj)
                {
                    return obj is CStringWide value && Equals(value);
                }

                /// <inheritdoc />
                public bool Equals(CStringWide other)
                {
                    return _pointer == other._pointer;
                }

                /// <inheritdoc />
                public override int GetHashCode()
                {
                    return _pointer.GetHashCode();
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool operator ==(CStringWide left, CStringWide right)
                {
                    return left._pointer == right._pointer;
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CBool" /> structures are not equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <c>false</c>.</returns>
                public static bool operator !=(CStringWide left, CStringWide right)
                {
                    return !(left == right);
                }

                /// <summary>
                ///     Returns a value that indicates whether two specified <see cref="CStringWide" /> structures are equal.
                /// </summary>
                /// <param name="left">The first <see cref="CStringWide" /> to compare.</param>
                /// <param name="right">The second <see cref="CStringWide" /> to compare.</param>
                /// <returns><c>true</c> if <paramref name="left" /> and <paramref name="right" /> are equal; otherwise, <c>false</c>.</returns>
                public static bool Equals(CStringWide left, CStringWide right)
                {
                    return left._pointer == right._pointer;
                }
            }
        }

        #endregion
    }
}

