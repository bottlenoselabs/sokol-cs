
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/lithiumtoast/c2cs
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using C2CS;

#nullable enable
#pragma warning disable 1591

public static unsafe partial class sokol_gfx
{
    private const string LibraryName = "sokol";
    private static IntPtr _libraryHandle;

    static sokol_gfx()
    {
        TryLoadApi();
    }

    public static bool TryLoadApi(string? libraryName = LibraryName)
    {
        UnloadApi();
        _libraryHandle = Runtime.LibraryLoad(libraryName!);
        if (_libraryHandle == IntPtr.Zero) return false;
        _LoadVirtualTable();
        return true;
    }

    public static void UnloadApi()
    {
        if (_libraryHandle == IntPtr.Zero) return;
        _UnloadVirtualTable();
        Runtime.LibraryUnload(_libraryHandle);
    }

    // Function @ sokol_gfx.h:2378:32
    public static void* sg_mtl_render_command_encoder()
    {
        return _virtualTable.sg_mtl_render_command_encoder();
    }

    // Function @ sokol_gfx.h:2375:32
    public static void* sg_mtl_device()
    {
        return _virtualTable.sg_mtl_device();
    }

    // Function @ sokol_gfx.h:2372:32
    public static void* sg_d3d11_device()
    {
        return _virtualTable.sg_d3d11_device();
    }

    // Function @ sokol_gfx.h:2363:25
    public static void sg_discard_context(sg_context ctx_id)
    {
        _virtualTable.sg_discard_context(ctx_id);
    }

    // Function @ sokol_gfx.h:2362:25
    public static void sg_activate_context(sg_context ctx_id)
    {
        _virtualTable.sg_activate_context(ctx_id);
    }

    // Function @ sokol_gfx.h:2361:31
    public static sg_context sg_setup_context()
    {
        return _virtualTable.sg_setup_context();
    }

    // Function @ sokol_gfx.h:2358:25
    public static void sg_fail_pass(sg_pass pass_id)
    {
        _virtualTable.sg_fail_pass(pass_id);
    }

    // Function @ sokol_gfx.h:2357:25
    public static void sg_fail_pipeline(sg_pipeline pip_id)
    {
        _virtualTable.sg_fail_pipeline(pip_id);
    }

    // Function @ sokol_gfx.h:2356:25
    public static void sg_fail_shader(sg_shader shd_id)
    {
        _virtualTable.sg_fail_shader(shd_id);
    }

    // Function @ sokol_gfx.h:2355:25
    public static void sg_fail_image(sg_image img_id)
    {
        _virtualTable.sg_fail_image(img_id);
    }

    // Function @ sokol_gfx.h:2354:25
    public static void sg_fail_buffer(sg_buffer buf_id)
    {
        _virtualTable.sg_fail_buffer(buf_id);
    }

    // Function @ sokol_gfx.h:2353:25
    public static CBool sg_uninit_pass(sg_pass pass_id)
    {
        return _virtualTable.sg_uninit_pass(pass_id);
    }

    // Function @ sokol_gfx.h:2352:25
    public static CBool sg_uninit_pipeline(sg_pipeline pip_id)
    {
        return _virtualTable.sg_uninit_pipeline(pip_id);
    }

    // Function @ sokol_gfx.h:2351:25
    public static CBool sg_uninit_shader(sg_shader shd_id)
    {
        return _virtualTable.sg_uninit_shader(shd_id);
    }

    // Function @ sokol_gfx.h:2350:25
    public static CBool sg_uninit_image(sg_image img_id)
    {
        return _virtualTable.sg_uninit_image(img_id);
    }

    // Function @ sokol_gfx.h:2349:25
    public static CBool sg_uninit_buffer(sg_buffer buf_id)
    {
        return _virtualTable.sg_uninit_buffer(buf_id);
    }

    // Function @ sokol_gfx.h:2348:25
    public static void sg_init_pass(sg_pass pass_id, sg_pass_desc* desc)
    {
        _virtualTable.sg_init_pass(pass_id, desc);
    }

    // Function @ sokol_gfx.h:2347:25
    public static void sg_init_pipeline(sg_pipeline pip_id, sg_pipeline_desc* desc)
    {
        _virtualTable.sg_init_pipeline(pip_id, desc);
    }

    // Function @ sokol_gfx.h:2346:25
    public static void sg_init_shader(sg_shader shd_id, sg_shader_desc* desc)
    {
        _virtualTable.sg_init_shader(shd_id, desc);
    }

    // Function @ sokol_gfx.h:2345:25
    public static void sg_init_image(sg_image img_id, sg_image_desc* desc)
    {
        _virtualTable.sg_init_image(img_id, desc);
    }

    // Function @ sokol_gfx.h:2344:25
    public static void sg_init_buffer(sg_buffer buf_id, sg_buffer_desc* desc)
    {
        _virtualTable.sg_init_buffer(buf_id, desc);
    }

    // Function @ sokol_gfx.h:2343:25
    public static void sg_dealloc_pass(sg_pass pass_id)
    {
        _virtualTable.sg_dealloc_pass(pass_id);
    }

    // Function @ sokol_gfx.h:2342:25
    public static void sg_dealloc_pipeline(sg_pipeline pip_id)
    {
        _virtualTable.sg_dealloc_pipeline(pip_id);
    }

    // Function @ sokol_gfx.h:2341:25
    public static void sg_dealloc_shader(sg_shader shd_id)
    {
        _virtualTable.sg_dealloc_shader(shd_id);
    }

    // Function @ sokol_gfx.h:2340:25
    public static void sg_dealloc_image(sg_image img_id)
    {
        _virtualTable.sg_dealloc_image(img_id);
    }

    // Function @ sokol_gfx.h:2339:25
    public static void sg_dealloc_buffer(sg_buffer buf_id)
    {
        _virtualTable.sg_dealloc_buffer(buf_id);
    }

    // Function @ sokol_gfx.h:2338:28
    public static sg_pass sg_alloc_pass()
    {
        return _virtualTable.sg_alloc_pass();
    }

    // Function @ sokol_gfx.h:2337:32
    public static sg_pipeline sg_alloc_pipeline()
    {
        return _virtualTable.sg_alloc_pipeline();
    }

    // Function @ sokol_gfx.h:2336:30
    public static sg_shader sg_alloc_shader()
    {
        return _virtualTable.sg_alloc_shader();
    }

    // Function @ sokol_gfx.h:2335:29
    public static sg_image sg_alloc_image()
    {
        return _virtualTable.sg_alloc_image();
    }

    // Function @ sokol_gfx.h:2334:30
    public static sg_buffer sg_alloc_buffer()
    {
        return _virtualTable.sg_alloc_buffer();
    }

    // Function @ sokol_gfx.h:2331:33
    public static sg_pass_desc sg_query_pass_defaults(sg_pass_desc* desc)
    {
        return _virtualTable.sg_query_pass_defaults(desc);
    }

    // Function @ sokol_gfx.h:2330:37
    public static sg_pipeline_desc sg_query_pipeline_defaults(sg_pipeline_desc* desc)
    {
        return _virtualTable.sg_query_pipeline_defaults(desc);
    }

    // Function @ sokol_gfx.h:2329:35
    public static sg_shader_desc sg_query_shader_defaults(sg_shader_desc* desc)
    {
        return _virtualTable.sg_query_shader_defaults(desc);
    }

    // Function @ sokol_gfx.h:2328:34
    public static sg_image_desc sg_query_image_defaults(sg_image_desc* desc)
    {
        return _virtualTable.sg_query_image_defaults(desc);
    }

    // Function @ sokol_gfx.h:2327:35
    public static sg_buffer_desc sg_query_buffer_defaults(sg_buffer_desc* desc)
    {
        return _virtualTable.sg_query_buffer_defaults(desc);
    }

    // Function @ sokol_gfx.h:2325:33
    public static sg_pass_info sg_query_pass_info(sg_pass pass)
    {
        return _virtualTable.sg_query_pass_info(pass);
    }

    // Function @ sokol_gfx.h:2324:37
    public static sg_pipeline_info sg_query_pipeline_info(sg_pipeline pip)
    {
        return _virtualTable.sg_query_pipeline_info(pip);
    }

    // Function @ sokol_gfx.h:2323:35
    public static sg_shader_info sg_query_shader_info(sg_shader shd)
    {
        return _virtualTable.sg_query_shader_info(shd);
    }

    // Function @ sokol_gfx.h:2322:34
    public static sg_image_info sg_query_image_info(sg_image img)
    {
        return _virtualTable.sg_query_image_info(img);
    }

    // Function @ sokol_gfx.h:2321:35
    public static sg_buffer_info sg_query_buffer_info(sg_buffer buf)
    {
        return _virtualTable.sg_query_buffer_info(buf);
    }

    // Function @ sokol_gfx.h:2319:38
    public static sg_resource_state sg_query_pass_state(sg_pass pass)
    {
        return _virtualTable.sg_query_pass_state(pass);
    }

    // Function @ sokol_gfx.h:2318:38
    public static sg_resource_state sg_query_pipeline_state(sg_pipeline pip)
    {
        return _virtualTable.sg_query_pipeline_state(pip);
    }

    // Function @ sokol_gfx.h:2317:38
    public static sg_resource_state sg_query_shader_state(sg_shader shd)
    {
        return _virtualTable.sg_query_shader_state(shd);
    }

    // Function @ sokol_gfx.h:2316:38
    public static sg_resource_state sg_query_image_state(sg_image img)
    {
        return _virtualTable.sg_query_image_state(img);
    }

    // Function @ sokol_gfx.h:2315:38
    public static sg_resource_state sg_query_buffer_state(sg_buffer buf)
    {
        return _virtualTable.sg_query_buffer_state(buf);
    }

    // Function @ sokol_gfx.h:2313:40
    public static sg_pixelformat_info sg_query_pixelformat(sg_pixel_format fmt)
    {
        return _virtualTable.sg_query_pixelformat(fmt);
    }

    // Function @ sokol_gfx.h:2312:30
    public static sg_limits sg_query_limits()
    {
        return _virtualTable.sg_query_limits();
    }

    // Function @ sokol_gfx.h:2311:32
    public static sg_features sg_query_features()
    {
        return _virtualTable.sg_query_features();
    }

    // Function @ sokol_gfx.h:2310:31
    public static sg_backend sg_query_backend()
    {
        return _virtualTable.sg_query_backend();
    }

    // Function @ sokol_gfx.h:2309:28
    public static sg_desc sg_query_desc()
    {
        return _virtualTable.sg_query_desc();
    }

    // Function @ sokol_gfx.h:2306:25
    public static void sg_commit()
    {
        _virtualTable.sg_commit();
    }

    // Function @ sokol_gfx.h:2305:25
    public static void sg_end_pass()
    {
        _virtualTable.sg_end_pass();
    }

    // Function @ sokol_gfx.h:2304:25
    public static void sg_draw(int base_element, int num_elements, int num_instances)
    {
        _virtualTable.sg_draw(base_element, num_elements, num_instances);
    }

    // Function @ sokol_gfx.h:2303:25
    public static void sg_apply_uniforms(sg_shader_stage stage, int ub_index, sg_range* data)
    {
        _virtualTable.sg_apply_uniforms(stage, ub_index, data);
    }

    // Function @ sokol_gfx.h:2302:25
    public static void sg_apply_bindings(sg_bindings* bindings)
    {
        _virtualTable.sg_apply_bindings(bindings);
    }

    // Function @ sokol_gfx.h:2301:25
    public static void sg_apply_pipeline(sg_pipeline pip)
    {
        _virtualTable.sg_apply_pipeline(pip);
    }

    // Function @ sokol_gfx.h:2300:25
    public static void sg_apply_scissor_rectf(float x, float y, float width, float height, CBool origin_top_left)
    {
        _virtualTable.sg_apply_scissor_rectf(x, y, width, height, origin_top_left);
    }

    // Function @ sokol_gfx.h:2299:25
    public static void sg_apply_scissor_rect(int x, int y, int width, int height, CBool origin_top_left)
    {
        _virtualTable.sg_apply_scissor_rect(x, y, width, height, origin_top_left);
    }

    // Function @ sokol_gfx.h:2298:25
    public static void sg_apply_viewportf(float x, float y, float width, float height, CBool origin_top_left)
    {
        _virtualTable.sg_apply_viewportf(x, y, width, height, origin_top_left);
    }

    // Function @ sokol_gfx.h:2297:25
    public static void sg_apply_viewport(int x, int y, int width, int height, CBool origin_top_left)
    {
        _virtualTable.sg_apply_viewport(x, y, width, height, origin_top_left);
    }

    // Function @ sokol_gfx.h:2296:25
    public static void sg_begin_pass(sg_pass pass, sg_pass_action* pass_action)
    {
        _virtualTable.sg_begin_pass(pass, pass_action);
    }

    // Function @ sokol_gfx.h:2295:25
    public static void sg_begin_default_passf(sg_pass_action* pass_action, float width, float height)
    {
        _virtualTable.sg_begin_default_passf(pass_action, width, height);
    }

    // Function @ sokol_gfx.h:2294:25
    public static void sg_begin_default_pass(sg_pass_action* pass_action, int width, int height)
    {
        _virtualTable.sg_begin_default_pass(pass_action, width, height);
    }

    // Function @ sokol_gfx.h:2291:25
    public static CBool sg_query_buffer_overflow(sg_buffer buf)
    {
        return _virtualTable.sg_query_buffer_overflow(buf);
    }

    // Function @ sokol_gfx.h:2290:24
    public static int sg_append_buffer(sg_buffer buf, sg_range* data)
    {
        return _virtualTable.sg_append_buffer(buf, data);
    }

    // Function @ sokol_gfx.h:2289:25
    public static void sg_update_image(sg_image img, sg_image_data* data)
    {
        _virtualTable.sg_update_image(img, data);
    }

    // Function @ sokol_gfx.h:2288:25
    public static void sg_update_buffer(sg_buffer buf, sg_range* data)
    {
        _virtualTable.sg_update_buffer(buf, data);
    }

    // Function @ sokol_gfx.h:2287:25
    public static void sg_destroy_pass(sg_pass pass)
    {
        _virtualTable.sg_destroy_pass(pass);
    }

    // Function @ sokol_gfx.h:2286:25
    public static void sg_destroy_pipeline(sg_pipeline pip)
    {
        _virtualTable.sg_destroy_pipeline(pip);
    }

    // Function @ sokol_gfx.h:2285:25
    public static void sg_destroy_shader(sg_shader shd)
    {
        _virtualTable.sg_destroy_shader(shd);
    }

    // Function @ sokol_gfx.h:2284:25
    public static void sg_destroy_image(sg_image img)
    {
        _virtualTable.sg_destroy_image(img);
    }

    // Function @ sokol_gfx.h:2283:25
    public static void sg_destroy_buffer(sg_buffer buf)
    {
        _virtualTable.sg_destroy_buffer(buf);
    }

    // Function @ sokol_gfx.h:2282:28
    public static sg_pass sg_make_pass(sg_pass_desc* desc)
    {
        return _virtualTable.sg_make_pass(desc);
    }

    // Function @ sokol_gfx.h:2281:32
    public static sg_pipeline sg_make_pipeline(sg_pipeline_desc* desc)
    {
        return _virtualTable.sg_make_pipeline(desc);
    }

    // Function @ sokol_gfx.h:2280:30
    public static sg_shader sg_make_shader(sg_shader_desc* desc)
    {
        return _virtualTable.sg_make_shader(desc);
    }

    // Function @ sokol_gfx.h:2279:29
    public static sg_image sg_make_image(sg_image_desc* desc)
    {
        return _virtualTable.sg_make_image(desc);
    }

    // Function @ sokol_gfx.h:2278:30
    public static sg_buffer sg_make_buffer(sg_buffer_desc* desc)
    {
        return _virtualTable.sg_make_buffer(desc);
    }

    // Function @ sokol_gfx.h:2275:25
    public static void sg_pop_debug_group()
    {
        _virtualTable.sg_pop_debug_group();
    }

    // Function @ sokol_gfx.h:2274:25
    public static void sg_push_debug_group(CString name)
    {
        _virtualTable.sg_push_debug_group(name);
    }

    // Function @ sokol_gfx.h:2273:35
    public static sg_trace_hooks sg_install_trace_hooks(sg_trace_hooks* trace_hooks)
    {
        return _virtualTable.sg_install_trace_hooks(trace_hooks);
    }

    // Function @ sokol_gfx.h:2272:25
    public static void sg_reset_state_cache()
    {
        _virtualTable.sg_reset_state_cache();
    }

    // Function @ sokol_gfx.h:2271:25
    public static CBool sg_isvalid()
    {
        return _virtualTable.sg_isvalid();
    }

    // Function @ sokol_gfx.h:2270:25
    public static void sg_shutdown()
    {
        _virtualTable.sg_shutdown();
    }

    // Function @ sokol_gfx.h:2269:25
    public static void sg_setup(sg_desc* desc)
    {
        _virtualTable.sg_setup(desc);
    }

    // FunctionPointer @ sokol_gfx.h:2235:19
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_VoidPtr_VoidPtr
    {
        public delegate* unmanaged<void*, void*> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:2234:19
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_VoidPtr
    {
        public delegate* unmanaged<void*> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:2027:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_CString_VoidPtr_Void
    {
        public delegate* unmanaged<CString, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:2016:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_pass_Sg_pass_descPtr_VoidPtr_Void
    {
        public delegate* unmanaged<sg_pass, sg_pass_desc*, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:2015:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_pipeline_Sg_pipeline_descPtr_VoidPtr_Void
    {
        public delegate* unmanaged<sg_pipeline, sg_pipeline_desc*, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:2014:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_shader_Sg_shader_descPtr_VoidPtr_Void
    {
        public delegate* unmanaged<sg_shader, sg_shader_desc*, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:2013:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_image_Sg_image_descPtr_VoidPtr_Void
    {
        public delegate* unmanaged<sg_image, sg_image_desc*, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:2012:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_buffer_Sg_buffer_descPtr_VoidPtr_Void
    {
        public delegate* unmanaged<sg_buffer, sg_buffer_desc*, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1999:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Int_Int_Int_VoidPtr_Void
    {
        public delegate* unmanaged<int, int, int, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1998:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_shader_stage_Int_Sg_rangePtr_VoidPtr_Void
    {
        public delegate* unmanaged<sg_shader_stage, int, sg_range*, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1997:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_bindingsPtr_VoidPtr_Void
    {
        public delegate* unmanaged<sg_bindings*, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1994:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Int_Int_Int_Int_CBool_VoidPtr_Void
    {
        public delegate* unmanaged<int, int, int, int, CBool, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1993:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_pass_Sg_pass_actionPtr_VoidPtr_Void
    {
        public delegate* unmanaged<sg_pass, sg_pass_action*, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1992:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_pass_actionPtr_Int_Int_VoidPtr_Void
    {
        public delegate* unmanaged<sg_pass_action*, int, int, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1991:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_buffer_Sg_rangePtr_Int_VoidPtr_Void
    {
        public delegate* unmanaged<sg_buffer, sg_range*, int, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1990:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_image_Sg_image_dataPtr_VoidPtr_Void
    {
        public delegate* unmanaged<sg_image, sg_image_data*, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1989:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_buffer_Sg_rangePtr_VoidPtr_Void
    {
        public delegate* unmanaged<sg_buffer, sg_range*, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1988:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_pass_VoidPtr_Void
    {
        public delegate* unmanaged<sg_pass, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1987:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_pipeline_VoidPtr_Void
    {
        public delegate* unmanaged<sg_pipeline, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1986:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_shader_VoidPtr_Void
    {
        public delegate* unmanaged<sg_shader, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1985:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_image_VoidPtr_Void
    {
        public delegate* unmanaged<sg_image, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1984:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_buffer_VoidPtr_Void
    {
        public delegate* unmanaged<sg_buffer, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1983:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_pass_descPtr_Sg_pass_VoidPtr_Void
    {
        public delegate* unmanaged<sg_pass_desc*, sg_pass, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1982:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_pipeline_descPtr_Sg_pipeline_VoidPtr_Void
    {
        public delegate* unmanaged<sg_pipeline_desc*, sg_pipeline, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1981:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_shader_descPtr_Sg_shader_VoidPtr_Void
    {
        public delegate* unmanaged<sg_shader_desc*, sg_shader, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1980:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_image_descPtr_Sg_image_VoidPtr_Void
    {
        public delegate* unmanaged<sg_image_desc*, sg_image, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1979:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_Sg_buffer_descPtr_Sg_buffer_VoidPtr_Void
    {
        public delegate* unmanaged<sg_buffer_desc*, sg_buffer, void*, void> Pointer;
    }

    // FunctionPointer @ sokol_gfx.h:1978:12
    [StructLayout(LayoutKind.Sequential)]
    public struct FnPtr_SOKOL_GFX_VoidPtr_Void
    {
        public delegate* unmanaged<void*, void> Pointer;
    }

    // Struct @ sokol_gfx.h:633:45
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct sg_context
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint id;
    }

    // Struct @ sokol_gfx.h:632:45
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct sg_pass
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint id;
    }

    // Struct @ sokol_gfx.h:631:45
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct sg_pipeline
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint id;
    }

    // Struct @ sokol_gfx.h:630:45
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct sg_shader
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint id;
    }

    // Struct @ sokol_gfx.h:629:45
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct sg_image
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint id;
    }

    // Struct @ sokol_gfx.h:628:45
    [StructLayout(LayoutKind.Explicit, Size = 4, Pack = 4)]
    public struct sg_buffer
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint id;
    }

    // Struct @ sokol_gfx.h:1962:3
    [StructLayout(LayoutKind.Explicit, Size = 80, Pack = 8)]
    public struct sg_pass_desc
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint _start_canary;

        [FieldOffset(4)] // size = 48, padding = 0
        public fixed uint _color_attachments[48 / 4]; // sg_pass_attachment_desc[4]

        public Span<sg_pass_attachment_desc> color_attachments
        {
            get
            {
                fixed (sg_pass_desc* @this = &this)
                {
                    var pointer = &@this->_color_attachments[0];
                    var span = new Span<sg_pass_attachment_desc>(pointer, 4);
                    return span;
                }
            }
        }

        [FieldOffset(52)] // size = 12, padding = 0
        public sg_pass_attachment_desc depth_stencil_attachment;

        [FieldOffset(64)] // size = 8, padding = 0
        public CString label;

        [FieldOffset(72)] // size = 4, padding = 4
        public uint _end_canary;
    }

    // Struct @ sokol_gfx.h:1954:3
    [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
    public struct sg_pass_attachment_desc
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public sg_image image;

        [FieldOffset(4)] // size = 4, padding = 0
        public int mip_level;

        [FieldOffset(8)] // size = 4, padding = 0
        public int slice;
    }

    // Struct @ sokol_gfx.h:1926:3
    [StructLayout(LayoutKind.Explicit, Size = 568, Pack = 8)]
    public struct sg_pipeline_desc
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint _start_canary;

        [FieldOffset(4)] // size = 4, padding = 0
        public sg_shader shader;

        [FieldOffset(8)] // size = 288, padding = 0
        public sg_layout_desc layout;

        [FieldOffset(296)] // size = 24, padding = 0
        public sg_depth_state depth;

        [FieldOffset(320)] // size = 40, padding = 0
        public sg_stencil_state stencil;

        [FieldOffset(360)] // size = 4, padding = 0
        public int color_count;

        [FieldOffset(364)] // size = 144, padding = 0
        public fixed uint _colors[144 / 4]; // sg_color_state[4]

        public Span<sg_color_state> colors
        {
            get
            {
                fixed (sg_pipeline_desc* @this = &this)
                {
                    var pointer = &@this->_colors[0];
                    var span = new Span<sg_color_state>(pointer, 4);
                    return span;
                }
            }
        }

        [FieldOffset(508)] // size = 4, padding = 0
        public sg_primitive_type primitive_type;

        [FieldOffset(512)] // size = 4, padding = 0
        public sg_index_type index_type;

        [FieldOffset(516)] // size = 4, padding = 0
        public sg_cull_mode cull_mode;

        [FieldOffset(520)] // size = 4, padding = 0
        public sg_face_winding face_winding;

        [FieldOffset(524)] // size = 4, padding = 0
        public int sample_count;

        [FieldOffset(528)] // size = 16, padding = 0
        public Rgba32F blend_color;

        [FieldOffset(544)] // size = 1, padding = 7
        public CBool alpha_to_coverage_enabled;

        [FieldOffset(552)] // size = 8, padding = 0
        public CString label;

        [FieldOffset(560)] // size = 4, padding = 4
        public uint _end_canary;
    }

    // Struct @ sokol_gfx.h:1907:3
    [StructLayout(LayoutKind.Explicit, Size = 36, Pack = 4)]
    public struct sg_color_state
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public sg_pixel_format pixel_format;

        [FieldOffset(4)] // size = 4, padding = 0
        public sg_color_mask write_mask;

        [FieldOffset(8)] // size = 28, padding = 0
        public sg_blend_state blend;
    }

    // Struct @ sokol_gfx.h:1901:3
    [StructLayout(LayoutKind.Explicit, Size = 28, Pack = 4)]
    public struct sg_blend_state
    {
        [FieldOffset(0)] // size = 1, padding = 3
        public CBool enabled;

        [FieldOffset(4)] // size = 4, padding = 0
        public sg_blend_factor src_factor_rgb;

        [FieldOffset(8)] // size = 4, padding = 0
        public sg_blend_factor dst_factor_rgb;

        [FieldOffset(12)] // size = 4, padding = 0
        public sg_blend_op op_rgb;

        [FieldOffset(16)] // size = 4, padding = 0
        public sg_blend_factor src_factor_alpha;

        [FieldOffset(20)] // size = 4, padding = 0
        public sg_blend_factor dst_factor_alpha;

        [FieldOffset(24)] // size = 4, padding = 0
        public sg_blend_op op_alpha;
    }

    // Struct @ sokol_gfx.h:1882:3
    [StructLayout(LayoutKind.Explicit, Size = 40, Pack = 4)]
    public struct sg_stencil_state
    {
        [FieldOffset(0)] // size = 1, padding = 3
        public CBool enabled;

        [FieldOffset(4)] // size = 16, padding = 0
        public sg_stencil_face_state front;

        [FieldOffset(20)] // size = 16, padding = 0
        public sg_stencil_face_state back;

        [FieldOffset(36)] // size = 1, padding = 0
        public byte read_mask;

        [FieldOffset(37)] // size = 1, padding = 0
        public byte write_mask;

        [FieldOffset(38)] // size = 1, padding = 1
        public byte @ref;
    }

    // Struct @ sokol_gfx.h:1873:3
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 4)]
    public struct sg_stencil_face_state
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public sg_compare_func compare;

        [FieldOffset(4)] // size = 4, padding = 0
        public sg_stencil_op fail_op;

        [FieldOffset(8)] // size = 4, padding = 0
        public sg_stencil_op depth_fail_op;

        [FieldOffset(12)] // size = 4, padding = 0
        public sg_stencil_op pass_op;
    }

    // Struct @ sokol_gfx.h:1891:3
    [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 4)]
    public struct sg_depth_state
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public sg_pixel_format pixel_format;

        [FieldOffset(4)] // size = 4, padding = 0
        public sg_compare_func compare;

        [FieldOffset(8)] // size = 1, padding = 3
        public CBool write_enabled;

        [FieldOffset(12)] // size = 4, padding = 0
        public float bias;

        [FieldOffset(16)] // size = 4, padding = 0
        public float bias_slope_scale;

        [FieldOffset(20)] // size = 4, padding = 0
        public float bias_clamp;
    }

    // Struct @ sokol_gfx.h:1866:3
    [StructLayout(LayoutKind.Explicit, Size = 288, Pack = 4)]
    public struct sg_layout_desc
    {
        [FieldOffset(0)] // size = 96, padding = 0
        public fixed uint _buffers[96 / 4]; // sg_buffer_layout_desc[8]

        public Span<sg_buffer_layout_desc> buffers
        {
            get
            {
                fixed (sg_layout_desc* @this = &this)
                {
                    var pointer = &@this->_buffers[0];
                    var span = new Span<sg_buffer_layout_desc>(pointer, 8);
                    return span;
                }
            }
        }

        [FieldOffset(96)] // size = 192, padding = 0
        public fixed uint _attrs[192 / 4]; // sg_vertex_attr_desc[16]

        public Span<sg_vertex_attr_desc> attrs
        {
            get
            {
                fixed (sg_layout_desc* @this = &this)
                {
                    var pointer = &@this->_attrs[0];
                    var span = new Span<sg_vertex_attr_desc>(pointer, 16);
                    return span;
                }
            }
        }
    }

    // Struct @ sokol_gfx.h:1861:3
    [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
    public struct sg_vertex_attr_desc
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public int buffer_index;

        [FieldOffset(4)] // size = 4, padding = 0
        public int offset;

        [FieldOffset(8)] // size = 4, padding = 0
        public sg_vertex_format format;
    }

    // Struct @ sokol_gfx.h:1852:3
    [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
    public struct sg_buffer_layout_desc
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public int stride;

        [FieldOffset(4)] // size = 4, padding = 0
        public sg_vertex_step step_func;

        [FieldOffset(8)] // size = 4, padding = 0
        public int step_rate;
    }

    // Struct @ sokol_gfx.h:1774:3
    [StructLayout(LayoutKind.Explicit, Size = 2984, Pack = 8)]
    public struct sg_shader_desc
    {
        [FieldOffset(0)] // size = 4, padding = 4
        public uint _start_canary;

        [FieldOffset(8)] // size = 384, padding = 0
        public fixed ulong _attrs[384 / 8]; // sg_shader_attr_desc[16]

        public Span<sg_shader_attr_desc> attrs
        {
            get
            {
                fixed (sg_shader_desc* @this = &this)
                {
                    var pointer = &@this->_attrs[0];
                    var span = new Span<sg_shader_attr_desc>(pointer, 16);
                    return span;
                }
            }
        }

        [FieldOffset(392)] // size = 1288, padding = 0
        public sg_shader_stage_desc vs;

        [FieldOffset(1680)] // size = 1288, padding = 0
        public sg_shader_stage_desc fs;

        [FieldOffset(2968)] // size = 8, padding = 0
        public CString label;

        [FieldOffset(2976)] // size = 4, padding = 4
        public uint _end_canary;
    }

    // Struct @ sokol_gfx.h:1765:3
    [StructLayout(LayoutKind.Explicit, Size = 1288, Pack = 8)]
    public struct sg_shader_stage_desc
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public CString source;

        [FieldOffset(8)] // size = 16, padding = 0
        public sg_range bytecode;

        [FieldOffset(24)] // size = 8, padding = 0
        public CString entry;

        [FieldOffset(32)] // size = 8, padding = 0
        public CString d3d11_target;

        [FieldOffset(40)] // size = 1056, padding = 0
        public fixed ulong _uniform_blocks[1056 / 8]; // sg_shader_uniform_block_desc[4]

        public Span<sg_shader_uniform_block_desc> uniform_blocks
        {
            get
            {
                fixed (sg_shader_stage_desc* @this = &this)
                {
                    var pointer = &@this->_uniform_blocks[0];
                    var span = new Span<sg_shader_uniform_block_desc>(pointer, 4);
                    return span;
                }
            }
        }

        [FieldOffset(1096)] // size = 192, padding = 0
        public fixed ulong _images[192 / 8]; // sg_shader_image_desc[12]

        public Span<sg_shader_image_desc> images
        {
            get
            {
                fixed (sg_shader_stage_desc* @this = &this)
                {
                    var pointer = &@this->_images[0];
                    var span = new Span<sg_shader_image_desc>(pointer, 12);
                    return span;
                }
            }
        }
    }

    // Struct @ sokol_gfx.h:1756:3
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct sg_shader_image_desc
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public CString name;

        [FieldOffset(8)] // size = 4, padding = 0
        public sg_image_type image_type;

        [FieldOffset(12)] // size = 4, padding = 0
        public sg_sampler_type sampler_type;
    }

    // Struct @ sokol_gfx.h:1750:3
    [StructLayout(LayoutKind.Explicit, Size = 264, Pack = 8)]
    public struct sg_shader_uniform_block_desc
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public ulong size;

        [FieldOffset(8)] // size = 256, padding = 0
        public fixed ulong _uniforms[256 / 8]; // sg_shader_uniform_desc[16]

        public Span<sg_shader_uniform_desc> uniforms
        {
            get
            {
                fixed (sg_shader_uniform_block_desc* @this = &this)
                {
                    var pointer = &@this->_uniforms[0];
                    var span = new Span<sg_shader_uniform_desc>(pointer, 16);
                    return span;
                }
            }
        }
    }

    // Struct @ sokol_gfx.h:1745:3
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct sg_shader_uniform_desc
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public CString name;

        [FieldOffset(8)] // size = 4, padding = 0
        public sg_uniform_type type;

        [FieldOffset(12)] // size = 4, padding = 0
        public int array_count;
    }

    // Struct @ sokol_gfx.h:645:3
    [StructLayout(LayoutKind.Explicit, Size = 16, Pack = 8)]
    public struct sg_range
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* ptr;

        [FieldOffset(8)] // size = 8, padding = 0
        public ulong size;
    }

    // Struct @ sokol_gfx.h:1739:3
    [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
    public struct sg_shader_attr_desc
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public CString name;

        [FieldOffset(8)] // size = 8, padding = 0
        public CString sem_name;

        [FieldOffset(16)] // size = 4, padding = 4
        public int sem_index;
    }

    // Struct @ sokol_gfx.h:1699:3
    [StructLayout(LayoutKind.Explicit, Size = 1688, Pack = 8)]
    public struct sg_image_desc
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint _start_canary;

        [FieldOffset(4)] // size = 4, padding = 0
        public sg_image_type type;

        [FieldOffset(8)] // size = 1, padding = 3
        public CBool render_target;

        [FieldOffset(12)] // size = 4, padding = 0
        public int width;

        [FieldOffset(16)] // size = 4, padding = 0
        public int height;

        [FieldOffset(20)] // size = 4, padding = 0
        public int num_slices;

        [FieldOffset(24)] // size = 4, padding = 0
        public int num_mipmaps;

        [FieldOffset(28)] // size = 4, padding = 0
        public sg_usage usage;

        [FieldOffset(32)] // size = 4, padding = 0
        public sg_pixel_format pixel_format;

        [FieldOffset(36)] // size = 4, padding = 0
        public int sample_count;

        [FieldOffset(40)] // size = 4, padding = 0
        public sg_filter min_filter;

        [FieldOffset(44)] // size = 4, padding = 0
        public sg_filter mag_filter;

        [FieldOffset(48)] // size = 4, padding = 0
        public sg_wrap wrap_u;

        [FieldOffset(52)] // size = 4, padding = 0
        public sg_wrap wrap_v;

        [FieldOffset(56)] // size = 4, padding = 0
        public sg_wrap wrap_w;

        [FieldOffset(60)] // size = 4, padding = 0
        public sg_border_color border_color;

        [FieldOffset(64)] // size = 4, padding = 0
        public uint max_anisotropy;

        [FieldOffset(68)] // size = 4, padding = 0
        public float min_lod;

        [FieldOffset(72)] // size = 4, padding = 4
        public float max_lod;

        [FieldOffset(80)] // size = 1536, padding = 0
        public sg_image_data data;

        [FieldOffset(1616)] // size = 8, padding = 0
        public CString label;

        [FieldOffset(1624)] // size = 8, padding = 0
        public fixed uint _gl_textures[8 / 4]; // uint32_t[2]

        public Span<uint> gl_textures
        {
            get
            {
                fixed (sg_image_desc* @this = &this)
                {
                    var pointer = &@this->_gl_textures[0];
                    var span = new Span<uint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(1632)] // size = 4, padding = 4
        public uint gl_texture_target;

        [FieldOffset(1640)] // size = 16, padding = 0
        public fixed ulong _mtl_textures[16 / 8]; // void*[2]

        public Span<IntPtr> mtl_textures
        {
            get
            {
                fixed (sg_image_desc* @this = &this)
                {
                    var pointer = &@this->_mtl_textures[0];
                    var span = new Span<IntPtr>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(1656)] // size = 8, padding = 0
        public void* d3d11_texture;

        [FieldOffset(1664)] // size = 8, padding = 0
        public void* d3d11_shader_resource_view;

        [FieldOffset(1672)] // size = 8, padding = 0
        public void* wgpu_texture;

        [FieldOffset(1680)] // size = 4, padding = 4
        public uint _end_canary;
    }

    // Struct @ sokol_gfx.h:1594:3
    [StructLayout(LayoutKind.Explicit, Size = 1536, Pack = 8)]
    public struct sg_image_data
    {
        [FieldOffset(0)] // size = 1536, padding = 0
        public fixed ulong _subimage[1536 / 8]; // sg_range[6]

        public Span<sg_range> subimage
        {
            get
            {
                fixed (sg_image_data* @this = &this)
                {
                    var pointer = &@this->_subimage[0];
                    var span = new Span<sg_range>(pointer, 6);
                    return span;
                }
            }
        }
    }

    // Struct @ sokol_gfx.h:1583:3
    [StructLayout(LayoutKind.Explicit, Size = 96, Pack = 8)]
    public struct sg_buffer_desc
    {
        [FieldOffset(0)] // size = 4, padding = 4
        public uint _start_canary;

        [FieldOffset(8)] // size = 8, padding = 0
        public ulong size;

        [FieldOffset(16)] // size = 4, padding = 0
        public sg_buffer_type type;

        [FieldOffset(20)] // size = 4, padding = 0
        public sg_usage usage;

        [FieldOffset(24)] // size = 16, padding = 0
        public sg_range data;

        [FieldOffset(40)] // size = 8, padding = 0
        public CString label;

        [FieldOffset(48)] // size = 8, padding = 0
        public fixed uint _gl_buffers[8 / 4]; // uint32_t[2]

        public Span<uint> gl_buffers
        {
            get
            {
                fixed (sg_buffer_desc* @this = &this)
                {
                    var pointer = &@this->_gl_buffers[0];
                    var span = new Span<uint>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(56)] // size = 16, padding = 0
        public fixed ulong _mtl_buffers[16 / 8]; // void*[2]

        public Span<IntPtr> mtl_buffers
        {
            get
            {
                fixed (sg_buffer_desc* @this = &this)
                {
                    var pointer = &@this->_mtl_buffers[0];
                    var span = new Span<IntPtr>(pointer, 2);
                    return span;
                }
            }
        }

        [FieldOffset(72)] // size = 8, padding = 0
        public void* d3d11_buffer;

        [FieldOffset(80)] // size = 8, padding = 0
        public void* wgpu_buffer;

        [FieldOffset(88)] // size = 4, padding = 4
        public uint _end_canary;
    }

    // Struct @ sokol_gfx.h:2096:3
    [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
    public struct sg_pass_info
    {
        [FieldOffset(0)] // size = 12, padding = 0
        public sg_slot_info slot;
    }

    // Struct @ sokol_gfx.h:2065:3
    [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
    public struct sg_slot_info
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public sg_resource_state state;

        [FieldOffset(4)] // size = 4, padding = 0
        public uint res_id;

        [FieldOffset(8)] // size = 4, padding = 0
        public uint ctx_id;
    }

    // Struct @ sokol_gfx.h:2092:3
    [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
    public struct sg_pipeline_info
    {
        [FieldOffset(0)] // size = 12, padding = 0
        public sg_slot_info slot;
    }

    // Struct @ sokol_gfx.h:2088:3
    [StructLayout(LayoutKind.Explicit, Size = 12, Pack = 4)]
    public struct sg_shader_info
    {
        [FieldOffset(0)] // size = 12, padding = 0
        public sg_slot_info slot;
    }

    // Struct @ sokol_gfx.h:2084:3
    [StructLayout(LayoutKind.Explicit, Size = 32, Pack = 4)]
    public struct sg_image_info
    {
        [FieldOffset(0)] // size = 12, padding = 0
        public sg_slot_info slot;

        [FieldOffset(12)] // size = 4, padding = 0
        public uint upd_frame_index;

        [FieldOffset(16)] // size = 4, padding = 0
        public int num_slots;

        [FieldOffset(20)] // size = 4, padding = 0
        public int active_slot;

        [FieldOffset(24)] // size = 4, padding = 0
        public int width;

        [FieldOffset(28)] // size = 4, padding = 0
        public int height;
    }

    // Struct @ sokol_gfx.h:2075:3
    [StructLayout(LayoutKind.Explicit, Size = 36, Pack = 4)]
    public struct sg_buffer_info
    {
        [FieldOffset(0)] // size = 12, padding = 0
        public sg_slot_info slot;

        [FieldOffset(12)] // size = 4, padding = 0
        public uint update_frame_index;

        [FieldOffset(16)] // size = 4, padding = 0
        public uint append_frame_index;

        [FieldOffset(20)] // size = 4, padding = 0
        public int append_pos;

        [FieldOffset(24)] // size = 1, padding = 3
        public CBool append_overflow;

        [FieldOffset(28)] // size = 4, padding = 0
        public int num_slots;

        [FieldOffset(32)] // size = 4, padding = 0
        public int active_slot;
    }

    // Struct @ sokol_gfx.h:844:3
    [StructLayout(LayoutKind.Explicit, Size = 6, Pack = 1)]
    public struct sg_pixelformat_info
    {
        [FieldOffset(0)] // size = 1, padding = 0
        public CBool sample;

        [FieldOffset(1)] // size = 1, padding = 0
        public CBool filter;

        [FieldOffset(2)] // size = 1, padding = 0
        public CBool render;

        [FieldOffset(3)] // size = 1, padding = 0
        public CBool blend;

        [FieldOffset(4)] // size = 1, padding = 0
        public CBool msaa;

        [FieldOffset(5)] // size = 1, padding = 0
        public CBool depth;
    }

    // Struct @ sokol_gfx.h:876:3
    [StructLayout(LayoutKind.Explicit, Size = 28, Pack = 4)]
    public struct sg_limits
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public int max_image_size_2d;

        [FieldOffset(4)] // size = 4, padding = 0
        public int max_image_size_cube;

        [FieldOffset(8)] // size = 4, padding = 0
        public int max_image_size_3d;

        [FieldOffset(12)] // size = 4, padding = 0
        public int max_image_size_array;

        [FieldOffset(16)] // size = 4, padding = 0
        public int max_image_array_layers;

        [FieldOffset(20)] // size = 4, padding = 0
        public int max_vertex_attrs;

        [FieldOffset(24)] // size = 4, padding = 0
        public int gl_max_vertex_uniform_vectors;
    }

    // Struct @ sokol_gfx.h:863:3
    [StructLayout(LayoutKind.Explicit, Size = 9, Pack = 1)]
    public struct sg_features
    {
        [FieldOffset(0)] // size = 1, padding = 0
        public CBool instancing;

        [FieldOffset(1)] // size = 1, padding = 0
        public CBool origin_top_left;

        [FieldOffset(2)] // size = 1, padding = 0
        public CBool multiple_render_targets;

        [FieldOffset(3)] // size = 1, padding = 0
        public CBool msaa_render_targets;

        [FieldOffset(4)] // size = 1, padding = 0
        public CBool imagetype_3d;

        [FieldOffset(5)] // size = 1, padding = 0
        public CBool imagetype_array;

        [FieldOffset(6)] // size = 1, padding = 0
        public CBool image_clamp_to_border;

        [FieldOffset(7)] // size = 1, padding = 0
        public CBool mrt_independent_blend_state;

        [FieldOffset(8)] // size = 1, padding = 0
        public CBool mrt_independent_write_mask;
    }

    // Struct @ sokol_gfx.h:2266:3
    [StructLayout(LayoutKind.Explicit, Size = 232, Pack = 8)]
    public struct sg_desc
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint _start_canary;

        [FieldOffset(4)] // size = 4, padding = 0
        public int buffer_pool_size;

        [FieldOffset(8)] // size = 4, padding = 0
        public int image_pool_size;

        [FieldOffset(12)] // size = 4, padding = 0
        public int shader_pool_size;

        [FieldOffset(16)] // size = 4, padding = 0
        public int pipeline_pool_size;

        [FieldOffset(20)] // size = 4, padding = 0
        public int pass_pool_size;

        [FieldOffset(24)] // size = 4, padding = 0
        public int context_pool_size;

        [FieldOffset(28)] // size = 4, padding = 0
        public int uniform_buffer_size;

        [FieldOffset(32)] // size = 4, padding = 0
        public int staging_buffer_size;

        [FieldOffset(36)] // size = 4, padding = 0
        public int sampler_cache_size;

        [FieldOffset(40)] // size = 184, padding = 0
        public sg_context_desc context;

        [FieldOffset(224)] // size = 4, padding = 4
        public uint _end_canary;
    }

    // Struct @ sokol_gfx.h:2251:3
    [StructLayout(LayoutKind.Explicit, Size = 184, Pack = 8)]
    public struct sg_context_desc
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public sg_pixel_format color_format;

        [FieldOffset(4)] // size = 4, padding = 0
        public sg_pixel_format depth_format;

        [FieldOffset(8)] // size = 4, padding = 0
        public int sample_count;

        [FieldOffset(12)] // size = 1, padding = 3
        public sg_gl_context_desc gl;

        [FieldOffset(16)] // size = 48, padding = 0
        public sg_metal_context_desc metal;

        [FieldOffset(64)] // size = 56, padding = 0
        public sg_d3d11_context_desc d3d11;

        [FieldOffset(120)] // size = 64, padding = 0
        public sg_wgpu_context_desc wgpu;
    }

    // Struct @ sokol_gfx.h:2241:3
    [StructLayout(LayoutKind.Explicit, Size = 64, Pack = 8)]
    public struct sg_wgpu_context_desc
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* device;

        [FieldOffset(8)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr render_view_cb;

        [FieldOffset(16)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_VoidPtr render_view_userdata_cb;

        [FieldOffset(24)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr resolve_view_cb;

        [FieldOffset(32)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_VoidPtr resolve_view_userdata_cb;

        [FieldOffset(40)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr depth_stencil_view_cb;

        [FieldOffset(48)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_VoidPtr depth_stencil_view_userdata_cb;

        [FieldOffset(56)] // size = 8, padding = 0
        public void* user_data;
    }

    // Struct @ sokol_gfx.h:2230:3
    [StructLayout(LayoutKind.Explicit, Size = 56, Pack = 8)]
    public struct sg_d3d11_context_desc
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* device;

        [FieldOffset(8)] // size = 8, padding = 0
        public void* device_context;

        [FieldOffset(16)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr render_target_view_cb;

        [FieldOffset(24)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_VoidPtr render_target_view_userdata_cb;

        [FieldOffset(32)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr depth_stencil_view_cb;

        [FieldOffset(40)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_VoidPtr depth_stencil_view_userdata_cb;

        [FieldOffset(48)] // size = 8, padding = 0
        public void* user_data;
    }

    // Struct @ sokol_gfx.h:2220:3
    [StructLayout(LayoutKind.Explicit, Size = 48, Pack = 8)]
    public struct sg_metal_context_desc
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* device;

        [FieldOffset(8)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr renderpass_descriptor_cb;

        [FieldOffset(16)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_VoidPtr renderpass_descriptor_userdata_cb;

        [FieldOffset(24)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr drawable_cb;

        [FieldOffset(32)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_VoidPtr drawable_userdata_cb;

        [FieldOffset(40)] // size = 8, padding = 0
        public void* user_data;
    }

    // Struct @ sokol_gfx.h:2211:3
    [StructLayout(LayoutKind.Explicit, Size = 1, Pack = 1)]
    public struct sg_gl_context_desc
    {
        [FieldOffset(0)] // size = 1, padding = 0
        public CBool force_gles2;
    }

    // Struct @ sokol_gfx.h:1512:3
    [StructLayout(LayoutKind.Explicit, Size = 176, Pack = 4)]
    public struct sg_bindings
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint _start_canary;

        [FieldOffset(4)] // size = 32, padding = 0
        public fixed uint _vertex_buffers[32 / 4]; // sg_buffer[8]

        public Span<sg_buffer> vertex_buffers
        {
            get
            {
                fixed (sg_bindings* @this = &this)
                {
                    var pointer = &@this->_vertex_buffers[0];
                    var span = new Span<sg_buffer>(pointer, 8);
                    return span;
                }
            }
        }

        [FieldOffset(36)] // size = 32, padding = 0
        public fixed uint _vertex_buffer_offsets[32 / 4]; // int[8]

        public Span<int> vertex_buffer_offsets
        {
            get
            {
                fixed (sg_bindings* @this = &this)
                {
                    var pointer = &@this->_vertex_buffer_offsets[0];
                    var span = new Span<int>(pointer, 8);
                    return span;
                }
            }
        }

        [FieldOffset(68)] // size = 4, padding = 0
        public sg_buffer index_buffer;

        [FieldOffset(72)] // size = 4, padding = 0
        public int index_buffer_offset;

        [FieldOffset(76)] // size = 48, padding = 0
        public fixed uint _vs_images[48 / 4]; // sg_image[12]

        public Span<sg_image> vs_images
        {
            get
            {
                fixed (sg_bindings* @this = &this)
                {
                    var pointer = &@this->_vs_images[0];
                    var span = new Span<sg_image>(pointer, 12);
                    return span;
                }
            }
        }

        [FieldOffset(124)] // size = 48, padding = 0
        public fixed uint _fs_images[48 / 4]; // sg_image[12]

        public Span<sg_image> fs_images
        {
            get
            {
                fixed (sg_bindings* @this = &this)
                {
                    var pointer = &@this->_fs_images[0];
                    var span = new Span<sg_image>(pointer, 12);
                    return span;
                }
            }
        }

        [FieldOffset(172)] // size = 4, padding = 0
        public uint _end_canary;
    }

    // Struct @ sokol_gfx.h:1478:3
    [StructLayout(LayoutKind.Explicit, Size = 104, Pack = 4)]
    public struct sg_pass_action
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public uint _start_canary;

        [FieldOffset(4)] // size = 80, padding = 0
        public fixed uint _colors[80 / 4]; // sg_color_attachment_action[4]

        public Span<sg_color_attachment_action> colors
        {
            get
            {
                fixed (sg_pass_action* @this = &this)
                {
                    var pointer = &@this->_colors[0];
                    var span = new Span<sg_color_attachment_action>(pointer, 4);
                    return span;
                }
            }
        }

        [FieldOffset(84)] // size = 8, padding = 0
        public sg_depth_attachment_action depth;

        [FieldOffset(92)] // size = 8, padding = 0
        public sg_stencil_attachment_action stencil;

        [FieldOffset(100)] // size = 4, padding = 0
        public uint _end_canary;
    }

    // Struct @ sokol_gfx.h:1470:3
    [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 4)]
    public struct sg_stencil_attachment_action
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public sg_action action;

        [FieldOffset(4)] // size = 1, padding = 3
        public byte value;
    }

    // Struct @ sokol_gfx.h:1465:3
    [StructLayout(LayoutKind.Explicit, Size = 8, Pack = 4)]
    public struct sg_depth_attachment_action
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public sg_action action;

        [FieldOffset(4)] // size = 4, padding = 0
        public float value;
    }

    // Struct @ sokol_gfx.h:1460:3
    [StructLayout(LayoutKind.Explicit, Size = 20, Pack = 4)]
    public struct sg_color_attachment_action
    {
        [FieldOffset(0)] // size = 4, padding = 0
        public sg_action action;

        [FieldOffset(4)] // size = 16, padding = 0
        public Rgba32F value;
    }

    // Struct @ sokol_gfx.h:2038:3
    [StructLayout(LayoutKind.Explicit, Size = 488, Pack = 8)]
    public struct sg_trace_hooks
    {
        [FieldOffset(0)] // size = 8, padding = 0
        public void* user_data;

        [FieldOffset(8)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void reset_state_cache;

        [FieldOffset(16)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_buffer_descPtr_Sg_buffer_VoidPtr_Void make_buffer;

        [FieldOffset(24)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_image_descPtr_Sg_image_VoidPtr_Void make_image;

        [FieldOffset(32)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_shader_descPtr_Sg_shader_VoidPtr_Void make_shader;

        [FieldOffset(40)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pipeline_descPtr_Sg_pipeline_VoidPtr_Void make_pipeline;

        [FieldOffset(48)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pass_descPtr_Sg_pass_VoidPtr_Void make_pass;

        [FieldOffset(56)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_buffer_VoidPtr_Void destroy_buffer;

        [FieldOffset(64)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_image_VoidPtr_Void destroy_image;

        [FieldOffset(72)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_shader_VoidPtr_Void destroy_shader;

        [FieldOffset(80)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pipeline_VoidPtr_Void destroy_pipeline;

        [FieldOffset(88)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pass_VoidPtr_Void destroy_pass;

        [FieldOffset(96)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_buffer_Sg_rangePtr_VoidPtr_Void update_buffer;

        [FieldOffset(104)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_image_Sg_image_dataPtr_VoidPtr_Void update_image;

        [FieldOffset(112)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_buffer_Sg_rangePtr_Int_VoidPtr_Void append_buffer;

        [FieldOffset(120)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pass_actionPtr_Int_Int_VoidPtr_Void begin_default_pass;

        [FieldOffset(128)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pass_Sg_pass_actionPtr_VoidPtr_Void begin_pass;

        [FieldOffset(136)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Int_Int_Int_Int_CBool_VoidPtr_Void apply_viewport;

        [FieldOffset(144)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Int_Int_Int_Int_CBool_VoidPtr_Void apply_scissor_rect;

        [FieldOffset(152)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pipeline_VoidPtr_Void apply_pipeline;

        [FieldOffset(160)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_bindingsPtr_VoidPtr_Void apply_bindings;

        [FieldOffset(168)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_shader_stage_Int_Sg_rangePtr_VoidPtr_Void apply_uniforms;

        [FieldOffset(176)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Int_Int_Int_VoidPtr_Void draw;

        [FieldOffset(184)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void end_pass;

        [FieldOffset(192)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void commit;

        [FieldOffset(200)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_buffer_VoidPtr_Void alloc_buffer;

        [FieldOffset(208)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_image_VoidPtr_Void alloc_image;

        [FieldOffset(216)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_shader_VoidPtr_Void alloc_shader;

        [FieldOffset(224)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pipeline_VoidPtr_Void alloc_pipeline;

        [FieldOffset(232)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pass_VoidPtr_Void alloc_pass;

        [FieldOffset(240)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_buffer_VoidPtr_Void dealloc_buffer;

        [FieldOffset(248)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_image_VoidPtr_Void dealloc_image;

        [FieldOffset(256)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_shader_VoidPtr_Void dealloc_shader;

        [FieldOffset(264)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pipeline_VoidPtr_Void dealloc_pipeline;

        [FieldOffset(272)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pass_VoidPtr_Void dealloc_pass;

        [FieldOffset(280)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_buffer_Sg_buffer_descPtr_VoidPtr_Void init_buffer;

        [FieldOffset(288)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_image_Sg_image_descPtr_VoidPtr_Void init_image;

        [FieldOffset(296)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_shader_Sg_shader_descPtr_VoidPtr_Void init_shader;

        [FieldOffset(304)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pipeline_Sg_pipeline_descPtr_VoidPtr_Void init_pipeline;

        [FieldOffset(312)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pass_Sg_pass_descPtr_VoidPtr_Void init_pass;

        [FieldOffset(320)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_buffer_VoidPtr_Void uninit_buffer;

        [FieldOffset(328)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_image_VoidPtr_Void uninit_image;

        [FieldOffset(336)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_shader_VoidPtr_Void uninit_shader;

        [FieldOffset(344)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pipeline_VoidPtr_Void uninit_pipeline;

        [FieldOffset(352)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pass_VoidPtr_Void uninit_pass;

        [FieldOffset(360)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_buffer_VoidPtr_Void fail_buffer;

        [FieldOffset(368)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_image_VoidPtr_Void fail_image;

        [FieldOffset(376)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_shader_VoidPtr_Void fail_shader;

        [FieldOffset(384)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pipeline_VoidPtr_Void fail_pipeline;

        [FieldOffset(392)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_Sg_pass_VoidPtr_Void fail_pass;

        [FieldOffset(400)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_CString_VoidPtr_Void push_debug_group;

        [FieldOffset(408)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void pop_debug_group;

        [FieldOffset(416)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void err_buffer_pool_exhausted;

        [FieldOffset(424)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void err_image_pool_exhausted;

        [FieldOffset(432)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void err_shader_pool_exhausted;

        [FieldOffset(440)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void err_pipeline_pool_exhausted;

        [FieldOffset(448)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void err_pass_pool_exhausted;

        [FieldOffset(456)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void err_context_mismatch;

        [FieldOffset(464)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void err_pass_invalid;

        [FieldOffset(472)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void err_draw_invalid;

        [FieldOffset(480)] // size = 8, padding = 0
        public FnPtr_SOKOL_GFX_VoidPtr_Void err_bindings_invalid;
    }

    // Enum @ sokol_gfx.h:1249:3
    public enum sg_face_winding : uint
    {
        _SG_FACEWINDING_DEFAULT = 0U,
        SG_FACEWINDING_CCW = 1U,
        SG_FACEWINDING_CW = 2U,
        _SG_FACEWINDING_NUM = 3U,
        _SG_FACEWINDING_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1232:3
    public enum sg_cull_mode : uint
    {
        _SG_CULLMODE_DEFAULT = 0U,
        SG_CULLMODE_NONE = 1U,
        SG_CULLMODE_FRONT = 2U,
        SG_CULLMODE_BACK = 3U,
        _SG_CULLMODE_NUM = 4U,
        _SG_CULLMODE_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:981:3
    public enum sg_index_type : uint
    {
        _SG_INDEXTYPE_DEFAULT = 0U,
        SG_INDEXTYPE_NONE = 1U,
        SG_INDEXTYPE_UINT16 = 2U,
        SG_INDEXTYPE_UINT32 = 3U,
        _SG_INDEXTYPE_NUM = 4U,
        _SG_INDEXTYPE_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1074:3
    public enum sg_primitive_type : uint
    {
        _SG_PRIMITIVETYPE_DEFAULT = 0U,
        SG_PRIMITIVETYPE_POINTS = 1U,
        SG_PRIMITIVETYPE_LINES = 2U,
        SG_PRIMITIVETYPE_LINE_STRIP = 3U,
        SG_PRIMITIVETYPE_TRIANGLES = 4U,
        SG_PRIMITIVETYPE_TRIANGLE_STRIP = 5U,
        _SG_PRIMITIVETYPE_NUM = 6U,
        _SG_PRIMITIVETYPE_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1375:3
    public enum sg_blend_op : uint
    {
        _SG_BLENDOP_DEFAULT = 0U,
        SG_BLENDOP_ADD = 1U,
        SG_BLENDOP_SUBTRACT = 2U,
        SG_BLENDOP_REVERSE_SUBTRACT = 3U,
        _SG_BLENDOP_NUM = 4U,
        _SG_BLENDOP_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1351:3
    public enum sg_blend_factor : uint
    {
        _SG_BLENDFACTOR_DEFAULT = 0U,
        SG_BLENDFACTOR_ZERO = 1U,
        SG_BLENDFACTOR_ONE = 2U,
        SG_BLENDFACTOR_SRC_COLOR = 3U,
        SG_BLENDFACTOR_ONE_MINUS_SRC_COLOR = 4U,
        SG_BLENDFACTOR_SRC_ALPHA = 5U,
        SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA = 6U,
        SG_BLENDFACTOR_DST_COLOR = 7U,
        SG_BLENDFACTOR_ONE_MINUS_DST_COLOR = 8U,
        SG_BLENDFACTOR_DST_ALPHA = 9U,
        SG_BLENDFACTOR_ONE_MINUS_DST_ALPHA = 10U,
        SG_BLENDFACTOR_SRC_ALPHA_SATURATED = 11U,
        SG_BLENDFACTOR_BLEND_COLOR = 12U,
        SG_BLENDFACTOR_ONE_MINUS_BLEND_COLOR = 13U,
        SG_BLENDFACTOR_BLEND_ALPHA = 14U,
        SG_BLENDFACTOR_ONE_MINUS_BLEND_ALPHA = 15U,
        _SG_BLENDFACTOR_NUM = 16U,
        _SG_BLENDFACTOR_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1409:3
    public enum sg_color_mask : uint
    {
        _SG_COLORMASK_DEFAULT = 0U,
        SG_COLORMASK_NONE = 16U,
        SG_COLORMASK_R = 1U,
        SG_COLORMASK_G = 2U,
        SG_COLORMASK_RG = 3U,
        SG_COLORMASK_B = 4U,
        SG_COLORMASK_RB = 5U,
        SG_COLORMASK_GB = 6U,
        SG_COLORMASK_RGB = 7U,
        SG_COLORMASK_A = 8U,
        SG_COLORMASK_RA = 9U,
        SG_COLORMASK_GA = 10U,
        SG_COLORMASK_RGA = 11U,
        SG_COLORMASK_BA = 12U,
        SG_COLORMASK_RBA = 13U,
        SG_COLORMASK_GBA = 14U,
        SG_COLORMASK_RGBA = 15U,
        _SG_COLORMASK_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:828:3
    public enum sg_pixel_format : uint
    {
        _SG_PIXELFORMAT_DEFAULT = 0U,
        SG_PIXELFORMAT_NONE = 1U,
        SG_PIXELFORMAT_R8 = 2U,
        SG_PIXELFORMAT_R8SN = 3U,
        SG_PIXELFORMAT_R8UI = 4U,
        SG_PIXELFORMAT_R8SI = 5U,
        SG_PIXELFORMAT_R16 = 6U,
        SG_PIXELFORMAT_R16SN = 7U,
        SG_PIXELFORMAT_R16UI = 8U,
        SG_PIXELFORMAT_R16SI = 9U,
        SG_PIXELFORMAT_R16F = 10U,
        SG_PIXELFORMAT_RG8 = 11U,
        SG_PIXELFORMAT_RG8SN = 12U,
        SG_PIXELFORMAT_RG8UI = 13U,
        SG_PIXELFORMAT_RG8SI = 14U,
        SG_PIXELFORMAT_R32UI = 15U,
        SG_PIXELFORMAT_R32SI = 16U,
        SG_PIXELFORMAT_R32F = 17U,
        SG_PIXELFORMAT_RG16 = 18U,
        SG_PIXELFORMAT_RG16SN = 19U,
        SG_PIXELFORMAT_RG16UI = 20U,
        SG_PIXELFORMAT_RG16SI = 21U,
        SG_PIXELFORMAT_RG16F = 22U,
        SG_PIXELFORMAT_RGBA8 = 23U,
        SG_PIXELFORMAT_RGBA8SN = 24U,
        SG_PIXELFORMAT_RGBA8UI = 25U,
        SG_PIXELFORMAT_RGBA8SI = 26U,
        SG_PIXELFORMAT_BGRA8 = 27U,
        SG_PIXELFORMAT_RGB10A2 = 28U,
        SG_PIXELFORMAT_RG11B10F = 29U,
        SG_PIXELFORMAT_RG32UI = 30U,
        SG_PIXELFORMAT_RG32SI = 31U,
        SG_PIXELFORMAT_RG32F = 32U,
        SG_PIXELFORMAT_RGBA16 = 33U,
        SG_PIXELFORMAT_RGBA16SN = 34U,
        SG_PIXELFORMAT_RGBA16UI = 35U,
        SG_PIXELFORMAT_RGBA16SI = 36U,
        SG_PIXELFORMAT_RGBA16F = 37U,
        SG_PIXELFORMAT_RGBA32UI = 38U,
        SG_PIXELFORMAT_RGBA32SI = 39U,
        SG_PIXELFORMAT_RGBA32F = 40U,
        SG_PIXELFORMAT_DEPTH = 41U,
        SG_PIXELFORMAT_DEPTH_STENCIL = 42U,
        SG_PIXELFORMAT_BC1_RGBA = 43U,
        SG_PIXELFORMAT_BC2_RGBA = 44U,
        SG_PIXELFORMAT_BC3_RGBA = 45U,
        SG_PIXELFORMAT_BC4_R = 46U,
        SG_PIXELFORMAT_BC4_RSN = 47U,
        SG_PIXELFORMAT_BC5_RG = 48U,
        SG_PIXELFORMAT_BC5_RGSN = 49U,
        SG_PIXELFORMAT_BC6H_RGBF = 50U,
        SG_PIXELFORMAT_BC6H_RGBUF = 51U,
        SG_PIXELFORMAT_BC7_RGBA = 52U,
        SG_PIXELFORMAT_PVRTC_RGB_2BPP = 53U,
        SG_PIXELFORMAT_PVRTC_RGB_4BPP = 54U,
        SG_PIXELFORMAT_PVRTC_RGBA_2BPP = 55U,
        SG_PIXELFORMAT_PVRTC_RGBA_4BPP = 56U,
        SG_PIXELFORMAT_ETC2_RGB8 = 57U,
        SG_PIXELFORMAT_ETC2_RGB8A1 = 58U,
        SG_PIXELFORMAT_ETC2_RGBA8 = 59U,
        SG_PIXELFORMAT_ETC2_RG11 = 60U,
        SG_PIXELFORMAT_ETC2_RG11SN = 61U,
        _SG_PIXELFORMAT_NUM = 62U,
        _SG_PIXELFORMAT_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1313:3
    public enum sg_stencil_op : uint
    {
        _SG_STENCILOP_DEFAULT = 0U,
        SG_STENCILOP_KEEP = 1U,
        SG_STENCILOP_ZERO = 2U,
        SG_STENCILOP_REPLACE = 3U,
        SG_STENCILOP_INCR_CLAMP = 4U,
        SG_STENCILOP_DECR_CLAMP = 5U,
        SG_STENCILOP_INVERT = 6U,
        SG_STENCILOP_INCR_WRAP = 7U,
        SG_STENCILOP_DECR_WRAP = 8U,
        _SG_STENCILOP_NUM = 9U,
        _SG_STENCILOP_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1279:3
    public enum sg_compare_func : uint
    {
        _SG_COMPAREFUNC_DEFAULT = 0U,
        SG_COMPAREFUNC_NEVER = 1U,
        SG_COMPAREFUNC_LESS = 2U,
        SG_COMPAREFUNC_EQUAL = 3U,
        SG_COMPAREFUNC_LESS_EQUAL = 4U,
        SG_COMPAREFUNC_GREATER = 5U,
        SG_COMPAREFUNC_NOT_EQUAL = 6U,
        SG_COMPAREFUNC_GREATER_EQUAL = 7U,
        SG_COMPAREFUNC_ALWAYS = 8U,
        _SG_COMPAREFUNC_NUM = 9U,
        _SG_COMPAREFUNC_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1177:3
    public enum sg_vertex_format : uint
    {
        SG_VERTEXFORMAT_INVALID = 0U,
        SG_VERTEXFORMAT_FLOAT = 1U,
        SG_VERTEXFORMAT_FLOAT2 = 2U,
        SG_VERTEXFORMAT_FLOAT3 = 3U,
        SG_VERTEXFORMAT_FLOAT4 = 4U,
        SG_VERTEXFORMAT_BYTE4 = 5U,
        SG_VERTEXFORMAT_BYTE4N = 6U,
        SG_VERTEXFORMAT_UBYTE4 = 7U,
        SG_VERTEXFORMAT_UBYTE4N = 8U,
        SG_VERTEXFORMAT_SHORT2 = 9U,
        SG_VERTEXFORMAT_SHORT2N = 10U,
        SG_VERTEXFORMAT_USHORT2N = 11U,
        SG_VERTEXFORMAT_SHORT4 = 12U,
        SG_VERTEXFORMAT_SHORT4N = 13U,
        SG_VERTEXFORMAT_USHORT4N = 14U,
        SG_VERTEXFORMAT_UINT10_N2 = 15U,
        _SG_VERTEXFORMAT_NUM = 16U,
        _SG_VERTEXFORMAT_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1196:3
    public enum sg_vertex_step : uint
    {
        _SG_VERTEXSTEP_DEFAULT = 0U,
        SG_VERTEXSTEP_PER_VERTEX = 1U,
        SG_VERTEXSTEP_PER_INSTANCE = 2U,
        _SG_VERTEXSTEP_NUM = 3U,
        _SG_VERTEXSTEP_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1020:3
    public enum sg_sampler_type : uint
    {
        _SG_SAMPLERTYPE_DEFAULT = 0U,
        SG_SAMPLERTYPE_FLOAT = 1U,
        SG_SAMPLERTYPE_SINT = 2U,
        SG_SAMPLERTYPE_UINT = 3U
    }

    // Enum @ sokol_gfx.h:1003:3
    public enum sg_image_type : uint
    {
        _SG_IMAGETYPE_DEFAULT = 0U,
        SG_IMAGETYPE_2D = 1U,
        SG_IMAGETYPE_CUBE = 2U,
        SG_IMAGETYPE_3D = 3U,
        SG_IMAGETYPE_ARRAY = 4U,
        _SG_IMAGETYPE_NUM = 5U,
        _SG_IMAGETYPE_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1214:3
    public enum sg_uniform_type : uint
    {
        SG_UNIFORMTYPE_INVALID = 0U,
        SG_UNIFORMTYPE_FLOAT = 1U,
        SG_UNIFORMTYPE_FLOAT2 = 2U,
        SG_UNIFORMTYPE_FLOAT3 = 3U,
        SG_UNIFORMTYPE_FLOAT4 = 4U,
        SG_UNIFORMTYPE_MAT4 = 5U,
        _SG_UNIFORMTYPE_NUM = 6U,
        _SG_UNIFORMTYPE_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1150:3
    public enum sg_border_color : uint
    {
        _SG_BORDERCOLOR_DEFAULT = 0U,
        SG_BORDERCOLOR_TRANSPARENT_BLACK = 1U,
        SG_BORDERCOLOR_OPAQUE_BLACK = 2U,
        SG_BORDERCOLOR_OPAQUE_WHITE = 3U,
        _SG_BORDERCOLOR_NUM = 4U,
        _SG_BORDERCOLOR_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1133:3
    public enum sg_wrap : uint
    {
        _SG_WRAP_DEFAULT = 0U,
        SG_WRAP_REPEAT = 1U,
        SG_WRAP_CLAMP_TO_EDGE = 2U,
        SG_WRAP_CLAMP_TO_BORDER = 3U,
        SG_WRAP_MIRRORED_REPEAT = 4U,
        _SG_WRAP_NUM = 5U,
        _SG_WRAP_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1095:3
    public enum sg_filter : uint
    {
        _SG_FILTER_DEFAULT = 0U,
        SG_FILTER_NEAREST = 1U,
        SG_FILTER_LINEAR = 2U,
        SG_FILTER_NEAREST_MIPMAP_NEAREST = 3U,
        SG_FILTER_NEAREST_MIPMAP_LINEAR = 4U,
        SG_FILTER_LINEAR_MIPMAP_NEAREST = 5U,
        SG_FILTER_LINEAR_MIPMAP_LINEAR = 6U,
        _SG_FILTER_NUM = 7U,
        _SG_FILTER_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:946:3
    public enum sg_usage : uint
    {
        _SG_USAGE_DEFAULT = 0U,
        SG_USAGE_IMMUTABLE = 1U,
        SG_USAGE_DYNAMIC = 2U,
        SG_USAGE_STREAM = 3U,
        _SG_USAGE_NUM = 4U,
        _SG_USAGE_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:962:3
    public enum sg_buffer_type : uint
    {
        _SG_BUFFERTYPE_DEFAULT = 0U,
        SG_BUFFERTYPE_VERTEXBUFFER = 1U,
        SG_BUFFERTYPE_INDEXBUFFER = 2U,
        _SG_BUFFERTYPE_NUM = 3U,
        _SG_BUFFERTYPE_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:903:3
    public enum sg_resource_state : uint
    {
        SG_RESOURCESTATE_INITIAL = 0U,
        SG_RESOURCESTATE_ALLOC = 1U,
        SG_RESOURCESTATE_VALID = 2U,
        SG_RESOURCESTATE_FAILED = 3U,
        SG_RESOURCESTATE_INVALID = 4U,
        _SG_RESOURCESTATE_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:702:3
    public enum sg_backend : uint
    {
        SG_BACKEND_GLCORE33 = 0U,
        SG_BACKEND_GLES2 = 1U,
        SG_BACKEND_GLES3 = 2U,
        SG_BACKEND_D3D11 = 3U,
        SG_BACKEND_METAL_IOS = 4U,
        SG_BACKEND_METAL_MACOS = 5U,
        SG_BACKEND_METAL_SIMULATOR = 6U,
        SG_BACKEND_WGPU = 7U,
        SG_BACKEND_DUMMY = 8U
    }

    // Enum @ sokol_gfx.h:1054:3
    public enum sg_shader_stage : uint
    {
        SG_SHADERSTAGE_VS = 0U,
        SG_SHADERSTAGE_FS = 1U,
        _SG_SHADERSTAGE_FORCE_U32 = 2147483647U
    }

    // Enum @ sokol_gfx.h:1436:3
    public enum sg_action : uint
    {
        _SG_ACTION_DEFAULT = 0U,
        SG_ACTION_CLEAR = 1U,
        SG_ACTION_LOAD = 2U,
        SG_ACTION_DONTCARE = 3U,
        _SG_ACTION_NUM = 4U,
        _SG_ACTION_FORCE_U32 = 2147483647U
    }

    private static void _LoadVirtualTable()
    {
        #region "Functions"
        _virtualTable.sg_mtl_render_command_encoder = (delegate* unmanaged[Cdecl]<void*>)Runtime.LibraryGetExport(_libraryHandle, "sg_mtl_render_command_encoder");
        _virtualTable.sg_mtl_device = (delegate* unmanaged[Cdecl]<void*>)Runtime.LibraryGetExport(_libraryHandle, "sg_mtl_device");
        _virtualTable.sg_d3d11_device = (delegate* unmanaged[Cdecl]<void*>)Runtime.LibraryGetExport(_libraryHandle, "sg_d3d11_device");
        _virtualTable.sg_discard_context = (delegate* unmanaged[Cdecl]<sg_context, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_discard_context");
        _virtualTable.sg_activate_context = (delegate* unmanaged[Cdecl]<sg_context, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_activate_context");
        _virtualTable.sg_setup_context = (delegate* unmanaged[Cdecl]<sg_context>)Runtime.LibraryGetExport(_libraryHandle, "sg_setup_context");
        _virtualTable.sg_fail_pass = (delegate* unmanaged[Cdecl]<sg_pass, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_fail_pass");
        _virtualTable.sg_fail_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_fail_pipeline");
        _virtualTable.sg_fail_shader = (delegate* unmanaged[Cdecl]<sg_shader, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_fail_shader");
        _virtualTable.sg_fail_image = (delegate* unmanaged[Cdecl]<sg_image, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_fail_image");
        _virtualTable.sg_fail_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_fail_buffer");
        _virtualTable.sg_uninit_pass = (delegate* unmanaged[Cdecl]<sg_pass, CBool>)Runtime.LibraryGetExport(_libraryHandle, "sg_uninit_pass");
        _virtualTable.sg_uninit_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, CBool>)Runtime.LibraryGetExport(_libraryHandle, "sg_uninit_pipeline");
        _virtualTable.sg_uninit_shader = (delegate* unmanaged[Cdecl]<sg_shader, CBool>)Runtime.LibraryGetExport(_libraryHandle, "sg_uninit_shader");
        _virtualTable.sg_uninit_image = (delegate* unmanaged[Cdecl]<sg_image, CBool>)Runtime.LibraryGetExport(_libraryHandle, "sg_uninit_image");
        _virtualTable.sg_uninit_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, CBool>)Runtime.LibraryGetExport(_libraryHandle, "sg_uninit_buffer");
        _virtualTable.sg_init_pass = (delegate* unmanaged[Cdecl]<sg_pass, sg_pass_desc*, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_init_pass");
        _virtualTable.sg_init_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, sg_pipeline_desc*, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_init_pipeline");
        _virtualTable.sg_init_shader = (delegate* unmanaged[Cdecl]<sg_shader, sg_shader_desc*, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_init_shader");
        _virtualTable.sg_init_image = (delegate* unmanaged[Cdecl]<sg_image, sg_image_desc*, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_init_image");
        _virtualTable.sg_init_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, sg_buffer_desc*, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_init_buffer");
        _virtualTable.sg_dealloc_pass = (delegate* unmanaged[Cdecl]<sg_pass, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_dealloc_pass");
        _virtualTable.sg_dealloc_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_dealloc_pipeline");
        _virtualTable.sg_dealloc_shader = (delegate* unmanaged[Cdecl]<sg_shader, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_dealloc_shader");
        _virtualTable.sg_dealloc_image = (delegate* unmanaged[Cdecl]<sg_image, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_dealloc_image");
        _virtualTable.sg_dealloc_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_dealloc_buffer");
        _virtualTable.sg_alloc_pass = (delegate* unmanaged[Cdecl]<sg_pass>)Runtime.LibraryGetExport(_libraryHandle, "sg_alloc_pass");
        _virtualTable.sg_alloc_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline>)Runtime.LibraryGetExport(_libraryHandle, "sg_alloc_pipeline");
        _virtualTable.sg_alloc_shader = (delegate* unmanaged[Cdecl]<sg_shader>)Runtime.LibraryGetExport(_libraryHandle, "sg_alloc_shader");
        _virtualTable.sg_alloc_image = (delegate* unmanaged[Cdecl]<sg_image>)Runtime.LibraryGetExport(_libraryHandle, "sg_alloc_image");
        _virtualTable.sg_alloc_buffer = (delegate* unmanaged[Cdecl]<sg_buffer>)Runtime.LibraryGetExport(_libraryHandle, "sg_alloc_buffer");
        _virtualTable.sg_query_pass_defaults = (delegate* unmanaged[Cdecl]<sg_pass_desc*, sg_pass_desc>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_pass_defaults");
        _virtualTable.sg_query_pipeline_defaults = (delegate* unmanaged[Cdecl]<sg_pipeline_desc*, sg_pipeline_desc>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_pipeline_defaults");
        _virtualTable.sg_query_shader_defaults = (delegate* unmanaged[Cdecl]<sg_shader_desc*, sg_shader_desc>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_shader_defaults");
        _virtualTable.sg_query_image_defaults = (delegate* unmanaged[Cdecl]<sg_image_desc*, sg_image_desc>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_image_defaults");
        _virtualTable.sg_query_buffer_defaults = (delegate* unmanaged[Cdecl]<sg_buffer_desc*, sg_buffer_desc>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_buffer_defaults");
        _virtualTable.sg_query_pass_info = (delegate* unmanaged[Cdecl]<sg_pass, sg_pass_info>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_pass_info");
        _virtualTable.sg_query_pipeline_info = (delegate* unmanaged[Cdecl]<sg_pipeline, sg_pipeline_info>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_pipeline_info");
        _virtualTable.sg_query_shader_info = (delegate* unmanaged[Cdecl]<sg_shader, sg_shader_info>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_shader_info");
        _virtualTable.sg_query_image_info = (delegate* unmanaged[Cdecl]<sg_image, sg_image_info>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_image_info");
        _virtualTable.sg_query_buffer_info = (delegate* unmanaged[Cdecl]<sg_buffer, sg_buffer_info>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_buffer_info");
        _virtualTable.sg_query_pass_state = (delegate* unmanaged[Cdecl]<sg_pass, sg_resource_state>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_pass_state");
        _virtualTable.sg_query_pipeline_state = (delegate* unmanaged[Cdecl]<sg_pipeline, sg_resource_state>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_pipeline_state");
        _virtualTable.sg_query_shader_state = (delegate* unmanaged[Cdecl]<sg_shader, sg_resource_state>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_shader_state");
        _virtualTable.sg_query_image_state = (delegate* unmanaged[Cdecl]<sg_image, sg_resource_state>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_image_state");
        _virtualTable.sg_query_buffer_state = (delegate* unmanaged[Cdecl]<sg_buffer, sg_resource_state>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_buffer_state");
        _virtualTable.sg_query_pixelformat = (delegate* unmanaged[Cdecl]<sg_pixel_format, sg_pixelformat_info>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_pixelformat");
        _virtualTable.sg_query_limits = (delegate* unmanaged[Cdecl]<sg_limits>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_limits");
        _virtualTable.sg_query_features = (delegate* unmanaged[Cdecl]<sg_features>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_features");
        _virtualTable.sg_query_backend = (delegate* unmanaged[Cdecl]<sg_backend>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_backend");
        _virtualTable.sg_query_desc = (delegate* unmanaged[Cdecl]<sg_desc>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_desc");
        _virtualTable.sg_commit = (delegate* unmanaged[Cdecl]<void>)Runtime.LibraryGetExport(_libraryHandle, "sg_commit");
        _virtualTable.sg_end_pass = (delegate* unmanaged[Cdecl]<void>)Runtime.LibraryGetExport(_libraryHandle, "sg_end_pass");
        _virtualTable.sg_draw = (delegate* unmanaged[Cdecl]<int, int, int, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_draw");
        _virtualTable.sg_apply_uniforms = (delegate* unmanaged[Cdecl]<sg_shader_stage, int, sg_range*, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_apply_uniforms");
        _virtualTable.sg_apply_bindings = (delegate* unmanaged[Cdecl]<sg_bindings*, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_apply_bindings");
        _virtualTable.sg_apply_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_apply_pipeline");
        _virtualTable.sg_apply_scissor_rectf = (delegate* unmanaged[Cdecl]<float, float, float, float, CBool, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_apply_scissor_rectf");
        _virtualTable.sg_apply_scissor_rect = (delegate* unmanaged[Cdecl]<int, int, int, int, CBool, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_apply_scissor_rect");
        _virtualTable.sg_apply_viewportf = (delegate* unmanaged[Cdecl]<float, float, float, float, CBool, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_apply_viewportf");
        _virtualTable.sg_apply_viewport = (delegate* unmanaged[Cdecl]<int, int, int, int, CBool, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_apply_viewport");
        _virtualTable.sg_begin_pass = (delegate* unmanaged[Cdecl]<sg_pass, sg_pass_action*, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_begin_pass");
        _virtualTable.sg_begin_default_passf = (delegate* unmanaged[Cdecl]<sg_pass_action*, float, float, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_begin_default_passf");
        _virtualTable.sg_begin_default_pass = (delegate* unmanaged[Cdecl]<sg_pass_action*, int, int, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_begin_default_pass");
        _virtualTable.sg_query_buffer_overflow = (delegate* unmanaged[Cdecl]<sg_buffer, CBool>)Runtime.LibraryGetExport(_libraryHandle, "sg_query_buffer_overflow");
        _virtualTable.sg_append_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, sg_range*, int>)Runtime.LibraryGetExport(_libraryHandle, "sg_append_buffer");
        _virtualTable.sg_update_image = (delegate* unmanaged[Cdecl]<sg_image, sg_image_data*, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_update_image");
        _virtualTable.sg_update_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, sg_range*, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_update_buffer");
        _virtualTable.sg_destroy_pass = (delegate* unmanaged[Cdecl]<sg_pass, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_destroy_pass");
        _virtualTable.sg_destroy_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_destroy_pipeline");
        _virtualTable.sg_destroy_shader = (delegate* unmanaged[Cdecl]<sg_shader, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_destroy_shader");
        _virtualTable.sg_destroy_image = (delegate* unmanaged[Cdecl]<sg_image, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_destroy_image");
        _virtualTable.sg_destroy_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_destroy_buffer");
        _virtualTable.sg_make_pass = (delegate* unmanaged[Cdecl]<sg_pass_desc*, sg_pass>)Runtime.LibraryGetExport(_libraryHandle, "sg_make_pass");
        _virtualTable.sg_make_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline_desc*, sg_pipeline>)Runtime.LibraryGetExport(_libraryHandle, "sg_make_pipeline");
        _virtualTable.sg_make_shader = (delegate* unmanaged[Cdecl]<sg_shader_desc*, sg_shader>)Runtime.LibraryGetExport(_libraryHandle, "sg_make_shader");
        _virtualTable.sg_make_image = (delegate* unmanaged[Cdecl]<sg_image_desc*, sg_image>)Runtime.LibraryGetExport(_libraryHandle, "sg_make_image");
        _virtualTable.sg_make_buffer = (delegate* unmanaged[Cdecl]<sg_buffer_desc*, sg_buffer>)Runtime.LibraryGetExport(_libraryHandle, "sg_make_buffer");
        _virtualTable.sg_pop_debug_group = (delegate* unmanaged[Cdecl]<void>)Runtime.LibraryGetExport(_libraryHandle, "sg_pop_debug_group");
        _virtualTable.sg_push_debug_group = (delegate* unmanaged[Cdecl]<CString, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_push_debug_group");
        _virtualTable.sg_install_trace_hooks = (delegate* unmanaged[Cdecl]<sg_trace_hooks*, sg_trace_hooks>)Runtime.LibraryGetExport(_libraryHandle, "sg_install_trace_hooks");
        _virtualTable.sg_reset_state_cache = (delegate* unmanaged[Cdecl]<void>)Runtime.LibraryGetExport(_libraryHandle, "sg_reset_state_cache");
        _virtualTable.sg_isvalid = (delegate* unmanaged[Cdecl]<CBool>)Runtime.LibraryGetExport(_libraryHandle, "sg_isvalid");
        _virtualTable.sg_shutdown = (delegate* unmanaged[Cdecl]<void>)Runtime.LibraryGetExport(_libraryHandle, "sg_shutdown");
        _virtualTable.sg_setup = (delegate* unmanaged[Cdecl]<sg_desc*, void>)Runtime.LibraryGetExport(_libraryHandle, "sg_setup");
        #endregion

        #region "Variables"

        #endregion
    }

    private static void _UnloadVirtualTable()
    {
        #region "Functions"

        _virtualTable.sg_mtl_render_command_encoder = (delegate* unmanaged[Cdecl]<void*>)IntPtr.Zero;
        _virtualTable.sg_mtl_device = (delegate* unmanaged[Cdecl]<void*>)IntPtr.Zero;
        _virtualTable.sg_d3d11_device = (delegate* unmanaged[Cdecl]<void*>)IntPtr.Zero;
        _virtualTable.sg_discard_context = (delegate* unmanaged[Cdecl]<sg_context, void>)IntPtr.Zero;
        _virtualTable.sg_activate_context = (delegate* unmanaged[Cdecl]<sg_context, void>)IntPtr.Zero;
        _virtualTable.sg_setup_context = (delegate* unmanaged[Cdecl]<sg_context>)IntPtr.Zero;
        _virtualTable.sg_fail_pass = (delegate* unmanaged[Cdecl]<sg_pass, void>)IntPtr.Zero;
        _virtualTable.sg_fail_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, void>)IntPtr.Zero;
        _virtualTable.sg_fail_shader = (delegate* unmanaged[Cdecl]<sg_shader, void>)IntPtr.Zero;
        _virtualTable.sg_fail_image = (delegate* unmanaged[Cdecl]<sg_image, void>)IntPtr.Zero;
        _virtualTable.sg_fail_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, void>)IntPtr.Zero;
        _virtualTable.sg_uninit_pass = (delegate* unmanaged[Cdecl]<sg_pass, CBool>)IntPtr.Zero;
        _virtualTable.sg_uninit_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, CBool>)IntPtr.Zero;
        _virtualTable.sg_uninit_shader = (delegate* unmanaged[Cdecl]<sg_shader, CBool>)IntPtr.Zero;
        _virtualTable.sg_uninit_image = (delegate* unmanaged[Cdecl]<sg_image, CBool>)IntPtr.Zero;
        _virtualTable.sg_uninit_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, CBool>)IntPtr.Zero;
        _virtualTable.sg_init_pass = (delegate* unmanaged[Cdecl]<sg_pass, sg_pass_desc*, void>)IntPtr.Zero;
        _virtualTable.sg_init_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, sg_pipeline_desc*, void>)IntPtr.Zero;
        _virtualTable.sg_init_shader = (delegate* unmanaged[Cdecl]<sg_shader, sg_shader_desc*, void>)IntPtr.Zero;
        _virtualTable.sg_init_image = (delegate* unmanaged[Cdecl]<sg_image, sg_image_desc*, void>)IntPtr.Zero;
        _virtualTable.sg_init_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, sg_buffer_desc*, void>)IntPtr.Zero;
        _virtualTable.sg_dealloc_pass = (delegate* unmanaged[Cdecl]<sg_pass, void>)IntPtr.Zero;
        _virtualTable.sg_dealloc_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, void>)IntPtr.Zero;
        _virtualTable.sg_dealloc_shader = (delegate* unmanaged[Cdecl]<sg_shader, void>)IntPtr.Zero;
        _virtualTable.sg_dealloc_image = (delegate* unmanaged[Cdecl]<sg_image, void>)IntPtr.Zero;
        _virtualTable.sg_dealloc_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, void>)IntPtr.Zero;
        _virtualTable.sg_alloc_pass = (delegate* unmanaged[Cdecl]<sg_pass>)IntPtr.Zero;
        _virtualTable.sg_alloc_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline>)IntPtr.Zero;
        _virtualTable.sg_alloc_shader = (delegate* unmanaged[Cdecl]<sg_shader>)IntPtr.Zero;
        _virtualTable.sg_alloc_image = (delegate* unmanaged[Cdecl]<sg_image>)IntPtr.Zero;
        _virtualTable.sg_alloc_buffer = (delegate* unmanaged[Cdecl]<sg_buffer>)IntPtr.Zero;
        _virtualTable.sg_query_pass_defaults = (delegate* unmanaged[Cdecl]<sg_pass_desc*, sg_pass_desc>)IntPtr.Zero;
        _virtualTable.sg_query_pipeline_defaults = (delegate* unmanaged[Cdecl]<sg_pipeline_desc*, sg_pipeline_desc>)IntPtr.Zero;
        _virtualTable.sg_query_shader_defaults = (delegate* unmanaged[Cdecl]<sg_shader_desc*, sg_shader_desc>)IntPtr.Zero;
        _virtualTable.sg_query_image_defaults = (delegate* unmanaged[Cdecl]<sg_image_desc*, sg_image_desc>)IntPtr.Zero;
        _virtualTable.sg_query_buffer_defaults = (delegate* unmanaged[Cdecl]<sg_buffer_desc*, sg_buffer_desc>)IntPtr.Zero;
        _virtualTable.sg_query_pass_info = (delegate* unmanaged[Cdecl]<sg_pass, sg_pass_info>)IntPtr.Zero;
        _virtualTable.sg_query_pipeline_info = (delegate* unmanaged[Cdecl]<sg_pipeline, sg_pipeline_info>)IntPtr.Zero;
        _virtualTable.sg_query_shader_info = (delegate* unmanaged[Cdecl]<sg_shader, sg_shader_info>)IntPtr.Zero;
        _virtualTable.sg_query_image_info = (delegate* unmanaged[Cdecl]<sg_image, sg_image_info>)IntPtr.Zero;
        _virtualTable.sg_query_buffer_info = (delegate* unmanaged[Cdecl]<sg_buffer, sg_buffer_info>)IntPtr.Zero;
        _virtualTable.sg_query_pass_state = (delegate* unmanaged[Cdecl]<sg_pass, sg_resource_state>)IntPtr.Zero;
        _virtualTable.sg_query_pipeline_state = (delegate* unmanaged[Cdecl]<sg_pipeline, sg_resource_state>)IntPtr.Zero;
        _virtualTable.sg_query_shader_state = (delegate* unmanaged[Cdecl]<sg_shader, sg_resource_state>)IntPtr.Zero;
        _virtualTable.sg_query_image_state = (delegate* unmanaged[Cdecl]<sg_image, sg_resource_state>)IntPtr.Zero;
        _virtualTable.sg_query_buffer_state = (delegate* unmanaged[Cdecl]<sg_buffer, sg_resource_state>)IntPtr.Zero;
        _virtualTable.sg_query_pixelformat = (delegate* unmanaged[Cdecl]<sg_pixel_format, sg_pixelformat_info>)IntPtr.Zero;
        _virtualTable.sg_query_limits = (delegate* unmanaged[Cdecl]<sg_limits>)IntPtr.Zero;
        _virtualTable.sg_query_features = (delegate* unmanaged[Cdecl]<sg_features>)IntPtr.Zero;
        _virtualTable.sg_query_backend = (delegate* unmanaged[Cdecl]<sg_backend>)IntPtr.Zero;
        _virtualTable.sg_query_desc = (delegate* unmanaged[Cdecl]<sg_desc>)IntPtr.Zero;
        _virtualTable.sg_commit = (delegate* unmanaged[Cdecl]<void>)IntPtr.Zero;
        _virtualTable.sg_end_pass = (delegate* unmanaged[Cdecl]<void>)IntPtr.Zero;
        _virtualTable.sg_draw = (delegate* unmanaged[Cdecl]<int, int, int, void>)IntPtr.Zero;
        _virtualTable.sg_apply_uniforms = (delegate* unmanaged[Cdecl]<sg_shader_stage, int, sg_range*, void>)IntPtr.Zero;
        _virtualTable.sg_apply_bindings = (delegate* unmanaged[Cdecl]<sg_bindings*, void>)IntPtr.Zero;
        _virtualTable.sg_apply_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, void>)IntPtr.Zero;
        _virtualTable.sg_apply_scissor_rectf = (delegate* unmanaged[Cdecl]<float, float, float, float, CBool, void>)IntPtr.Zero;
        _virtualTable.sg_apply_scissor_rect = (delegate* unmanaged[Cdecl]<int, int, int, int, CBool, void>)IntPtr.Zero;
        _virtualTable.sg_apply_viewportf = (delegate* unmanaged[Cdecl]<float, float, float, float, CBool, void>)IntPtr.Zero;
        _virtualTable.sg_apply_viewport = (delegate* unmanaged[Cdecl]<int, int, int, int, CBool, void>)IntPtr.Zero;
        _virtualTable.sg_begin_pass = (delegate* unmanaged[Cdecl]<sg_pass, sg_pass_action*, void>)IntPtr.Zero;
        _virtualTable.sg_begin_default_passf = (delegate* unmanaged[Cdecl]<sg_pass_action*, float, float, void>)IntPtr.Zero;
        _virtualTable.sg_begin_default_pass = (delegate* unmanaged[Cdecl]<sg_pass_action*, int, int, void>)IntPtr.Zero;
        _virtualTable.sg_query_buffer_overflow = (delegate* unmanaged[Cdecl]<sg_buffer, CBool>)IntPtr.Zero;
        _virtualTable.sg_append_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, sg_range*, int>)IntPtr.Zero;
        _virtualTable.sg_update_image = (delegate* unmanaged[Cdecl]<sg_image, sg_image_data*, void>)IntPtr.Zero;
        _virtualTable.sg_update_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, sg_range*, void>)IntPtr.Zero;
        _virtualTable.sg_destroy_pass = (delegate* unmanaged[Cdecl]<sg_pass, void>)IntPtr.Zero;
        _virtualTable.sg_destroy_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline, void>)IntPtr.Zero;
        _virtualTable.sg_destroy_shader = (delegate* unmanaged[Cdecl]<sg_shader, void>)IntPtr.Zero;
        _virtualTable.sg_destroy_image = (delegate* unmanaged[Cdecl]<sg_image, void>)IntPtr.Zero;
        _virtualTable.sg_destroy_buffer = (delegate* unmanaged[Cdecl]<sg_buffer, void>)IntPtr.Zero;
        _virtualTable.sg_make_pass = (delegate* unmanaged[Cdecl]<sg_pass_desc*, sg_pass>)IntPtr.Zero;
        _virtualTable.sg_make_pipeline = (delegate* unmanaged[Cdecl]<sg_pipeline_desc*, sg_pipeline>)IntPtr.Zero;
        _virtualTable.sg_make_shader = (delegate* unmanaged[Cdecl]<sg_shader_desc*, sg_shader>)IntPtr.Zero;
        _virtualTable.sg_make_image = (delegate* unmanaged[Cdecl]<sg_image_desc*, sg_image>)IntPtr.Zero;
        _virtualTable.sg_make_buffer = (delegate* unmanaged[Cdecl]<sg_buffer_desc*, sg_buffer>)IntPtr.Zero;
        _virtualTable.sg_pop_debug_group = (delegate* unmanaged[Cdecl]<void>)IntPtr.Zero;
        _virtualTable.sg_push_debug_group = (delegate* unmanaged[Cdecl]<CString, void>)IntPtr.Zero;
        _virtualTable.sg_install_trace_hooks = (delegate* unmanaged[Cdecl]<sg_trace_hooks*, sg_trace_hooks>)IntPtr.Zero;
        _virtualTable.sg_reset_state_cache = (delegate* unmanaged[Cdecl]<void>)IntPtr.Zero;
        _virtualTable.sg_isvalid = (delegate* unmanaged[Cdecl]<CBool>)IntPtr.Zero;
        _virtualTable.sg_shutdown = (delegate* unmanaged[Cdecl]<void>)IntPtr.Zero;
        _virtualTable.sg_setup = (delegate* unmanaged[Cdecl]<sg_desc*, void>)IntPtr.Zero;

        #endregion

        #region "Variables"



        #endregion
    }

    // The virtual table represents a list of pointers to functions or variables which are resolved in a late manner.
    //	This allows for flexibility in swapping implementations at runtime.
    //	You can think of it in traditional OOP terms in C# as the locations of the virtual methods and/or properties of an object.
    public struct _VirtualTable
    {
        #region "Function Pointers"
        // These pointers hold the locations in the native library where functions are located at runtime.
        // See: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers

        public delegate* unmanaged[Cdecl]<void*> sg_mtl_render_command_encoder;
        public delegate* unmanaged[Cdecl]<void*> sg_mtl_device;
        public delegate* unmanaged[Cdecl]<void*> sg_d3d11_device;
        public delegate* unmanaged[Cdecl]<sg_context, void> sg_discard_context;
        public delegate* unmanaged[Cdecl]<sg_context, void> sg_activate_context;
        public delegate* unmanaged[Cdecl]<sg_context> sg_setup_context;
        public delegate* unmanaged[Cdecl]<sg_pass, void> sg_fail_pass;
        public delegate* unmanaged[Cdecl]<sg_pipeline, void> sg_fail_pipeline;
        public delegate* unmanaged[Cdecl]<sg_shader, void> sg_fail_shader;
        public delegate* unmanaged[Cdecl]<sg_image, void> sg_fail_image;
        public delegate* unmanaged[Cdecl]<sg_buffer, void> sg_fail_buffer;
        public delegate* unmanaged[Cdecl]<sg_pass, CBool> sg_uninit_pass;
        public delegate* unmanaged[Cdecl]<sg_pipeline, CBool> sg_uninit_pipeline;
        public delegate* unmanaged[Cdecl]<sg_shader, CBool> sg_uninit_shader;
        public delegate* unmanaged[Cdecl]<sg_image, CBool> sg_uninit_image;
        public delegate* unmanaged[Cdecl]<sg_buffer, CBool> sg_uninit_buffer;
        public delegate* unmanaged[Cdecl]<sg_pass, sg_pass_desc*, void> sg_init_pass;
        public delegate* unmanaged[Cdecl]<sg_pipeline, sg_pipeline_desc*, void> sg_init_pipeline;
        public delegate* unmanaged[Cdecl]<sg_shader, sg_shader_desc*, void> sg_init_shader;
        public delegate* unmanaged[Cdecl]<sg_image, sg_image_desc*, void> sg_init_image;
        public delegate* unmanaged[Cdecl]<sg_buffer, sg_buffer_desc*, void> sg_init_buffer;
        public delegate* unmanaged[Cdecl]<sg_pass, void> sg_dealloc_pass;
        public delegate* unmanaged[Cdecl]<sg_pipeline, void> sg_dealloc_pipeline;
        public delegate* unmanaged[Cdecl]<sg_shader, void> sg_dealloc_shader;
        public delegate* unmanaged[Cdecl]<sg_image, void> sg_dealloc_image;
        public delegate* unmanaged[Cdecl]<sg_buffer, void> sg_dealloc_buffer;
        public delegate* unmanaged[Cdecl]<sg_pass> sg_alloc_pass;
        public delegate* unmanaged[Cdecl]<sg_pipeline> sg_alloc_pipeline;
        public delegate* unmanaged[Cdecl]<sg_shader> sg_alloc_shader;
        public delegate* unmanaged[Cdecl]<sg_image> sg_alloc_image;
        public delegate* unmanaged[Cdecl]<sg_buffer> sg_alloc_buffer;
        public delegate* unmanaged[Cdecl]<sg_pass_desc*, sg_pass_desc> sg_query_pass_defaults;
        public delegate* unmanaged[Cdecl]<sg_pipeline_desc*, sg_pipeline_desc> sg_query_pipeline_defaults;
        public delegate* unmanaged[Cdecl]<sg_shader_desc*, sg_shader_desc> sg_query_shader_defaults;
        public delegate* unmanaged[Cdecl]<sg_image_desc*, sg_image_desc> sg_query_image_defaults;
        public delegate* unmanaged[Cdecl]<sg_buffer_desc*, sg_buffer_desc> sg_query_buffer_defaults;
        public delegate* unmanaged[Cdecl]<sg_pass, sg_pass_info> sg_query_pass_info;
        public delegate* unmanaged[Cdecl]<sg_pipeline, sg_pipeline_info> sg_query_pipeline_info;
        public delegate* unmanaged[Cdecl]<sg_shader, sg_shader_info> sg_query_shader_info;
        public delegate* unmanaged[Cdecl]<sg_image, sg_image_info> sg_query_image_info;
        public delegate* unmanaged[Cdecl]<sg_buffer, sg_buffer_info> sg_query_buffer_info;
        public delegate* unmanaged[Cdecl]<sg_pass, sg_resource_state> sg_query_pass_state;
        public delegate* unmanaged[Cdecl]<sg_pipeline, sg_resource_state> sg_query_pipeline_state;
        public delegate* unmanaged[Cdecl]<sg_shader, sg_resource_state> sg_query_shader_state;
        public delegate* unmanaged[Cdecl]<sg_image, sg_resource_state> sg_query_image_state;
        public delegate* unmanaged[Cdecl]<sg_buffer, sg_resource_state> sg_query_buffer_state;
        public delegate* unmanaged[Cdecl]<sg_pixel_format, sg_pixelformat_info> sg_query_pixelformat;
        public delegate* unmanaged[Cdecl]<sg_limits> sg_query_limits;
        public delegate* unmanaged[Cdecl]<sg_features> sg_query_features;
        public delegate* unmanaged[Cdecl]<sg_backend> sg_query_backend;
        public delegate* unmanaged[Cdecl]<sg_desc> sg_query_desc;
        public delegate* unmanaged[Cdecl]<void> sg_commit;
        public delegate* unmanaged[Cdecl]<void> sg_end_pass;
        public delegate* unmanaged[Cdecl]<int, int, int, void> sg_draw;
        public delegate* unmanaged[Cdecl]<sg_shader_stage, int, sg_range*, void> sg_apply_uniforms;
        public delegate* unmanaged[Cdecl]<sg_bindings*, void> sg_apply_bindings;
        public delegate* unmanaged[Cdecl]<sg_pipeline, void> sg_apply_pipeline;
        public delegate* unmanaged[Cdecl]<float, float, float, float, CBool, void> sg_apply_scissor_rectf;
        public delegate* unmanaged[Cdecl]<int, int, int, int, CBool, void> sg_apply_scissor_rect;
        public delegate* unmanaged[Cdecl]<float, float, float, float, CBool, void> sg_apply_viewportf;
        public delegate* unmanaged[Cdecl]<int, int, int, int, CBool, void> sg_apply_viewport;
        public delegate* unmanaged[Cdecl]<sg_pass, sg_pass_action*, void> sg_begin_pass;
        public delegate* unmanaged[Cdecl]<sg_pass_action*, float, float, void> sg_begin_default_passf;
        public delegate* unmanaged[Cdecl]<sg_pass_action*, int, int, void> sg_begin_default_pass;
        public delegate* unmanaged[Cdecl]<sg_buffer, CBool> sg_query_buffer_overflow;
        public delegate* unmanaged[Cdecl]<sg_buffer, sg_range*, int> sg_append_buffer;
        public delegate* unmanaged[Cdecl]<sg_image, sg_image_data*, void> sg_update_image;
        public delegate* unmanaged[Cdecl]<sg_buffer, sg_range*, void> sg_update_buffer;
        public delegate* unmanaged[Cdecl]<sg_pass, void> sg_destroy_pass;
        public delegate* unmanaged[Cdecl]<sg_pipeline, void> sg_destroy_pipeline;
        public delegate* unmanaged[Cdecl]<sg_shader, void> sg_destroy_shader;
        public delegate* unmanaged[Cdecl]<sg_image, void> sg_destroy_image;
        public delegate* unmanaged[Cdecl]<sg_buffer, void> sg_destroy_buffer;
        public delegate* unmanaged[Cdecl]<sg_pass_desc*, sg_pass> sg_make_pass;
        public delegate* unmanaged[Cdecl]<sg_pipeline_desc*, sg_pipeline> sg_make_pipeline;
        public delegate* unmanaged[Cdecl]<sg_shader_desc*, sg_shader> sg_make_shader;
        public delegate* unmanaged[Cdecl]<sg_image_desc*, sg_image> sg_make_image;
        public delegate* unmanaged[Cdecl]<sg_buffer_desc*, sg_buffer> sg_make_buffer;
        public delegate* unmanaged[Cdecl]<void> sg_pop_debug_group;
        public delegate* unmanaged[Cdecl]<CString, void> sg_push_debug_group;
        public delegate* unmanaged[Cdecl]<sg_trace_hooks*, sg_trace_hooks> sg_install_trace_hooks;
        public delegate* unmanaged[Cdecl]<void> sg_reset_state_cache;
        public delegate* unmanaged[Cdecl]<CBool> sg_isvalid;
        public delegate* unmanaged[Cdecl]<void> sg_shutdown;
        public delegate* unmanaged[Cdecl]<sg_desc*, void> sg_setup;

        #endregion

        #region "Variables"
        // These pointers hold the locations in the native library where global variables are located at runtime.
        //	The value pointed by these pointers are updated by reading/writing memory.



        #endregion
    }

    private static _VirtualTable _virtualTable;
}
