
//-------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the following tool:
//        https://github.com/lithiumtoast/c2cs
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ReSharper disable All
//-------------------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using C2CS;

#nullable enable
#pragma warning disable 1591

public static unsafe partial class sokol_args
{
    private const string LibraryName = "sokol";
    private static IntPtr _libraryHandle;

    static sokol_args()
    {
        TryLoadApi();
    }

    public static bool TryLoadApi(string? libraryName = LibraryName)
    {
        UnloadApi();
        _libraryHandle = Runtime.LibraryLoad(libraryName!);
        if (_libraryHandle == IntPtr.Zero) return false;
        _LoadVirtualTable();
        return true;
    }

    public static void UnloadApi()
    {
        if (_libraryHandle == IntPtr.Zero) return;
        _UnloadVirtualTable();
        Runtime.LibraryUnload(_libraryHandle);
    }

    // Function @ sokol_args.h:302:33
    public static CString sargs_value_at(int index)
    {
        return _virtualTable.sargs_value_at(index);
    }

    // Function @ sokol_args.h:300:33
    public static CString sargs_key_at(int index)
    {
        return _virtualTable.sargs_key_at(index);
    }

    // Function @ sokol_args.h:298:25
    public static int sargs_num_args()
    {
        return _virtualTable.sargs_num_args();
    }

    // Function @ sokol_args.h:296:25
    public static int sargs_find(CString key)
    {
        return _virtualTable.sargs_find(key);
    }

    // Function @ sokol_args.h:294:26
    public static CBool sargs_boolean(CString key)
    {
        return _virtualTable.sargs_boolean(key);
    }

    // Function @ sokol_args.h:292:26
    public static CBool sargs_equals(CString key, CString val)
    {
        return _virtualTable.sargs_equals(key, val);
    }

    // Function @ sokol_args.h:290:33
    public static CString sargs_value_def(CString key, CString def)
    {
        return _virtualTable.sargs_value_def(key, def);
    }

    // Function @ sokol_args.h:288:33
    public static CString sargs_value(CString key)
    {
        return _virtualTable.sargs_value(key);
    }

    // Function @ sokol_args.h:286:26
    public static CBool sargs_exists(CString key)
    {
        return _virtualTable.sargs_exists(key);
    }

    // Function @ sokol_args.h:284:26
    public static CBool sargs_isvalid()
    {
        return _virtualTable.sargs_isvalid();
    }

    // Function @ sokol_args.h:282:26
    public static void sargs_shutdown()
    {
        _virtualTable.sargs_shutdown();
    }

    // Function @ sokol_args.h:280:26
    public static void sargs_setup(sargs_desc* desc)
    {
        _virtualTable.sargs_setup(desc);
    }

    // Struct @ sokol_args.h:277:3
    [StructLayout(LayoutKind.Explicit, Size = 24, Pack = 8)]
    public struct sargs_desc
    {
        [FieldOffset(0)] // size = 4, padding = 4
        public int argc;

        [FieldOffset(8)] // size = 8, padding = 0
        public CString* argv;

        [FieldOffset(16)] // size = 4, padding = 0
        public int max_args;

        [FieldOffset(20)] // size = 4, padding = 0
        public int buf_size;
    }

    private static void _LoadVirtualTable()
    {
        #region "Functions"

        _virtualTable.sargs_value_at = (delegate* unmanaged[Cdecl]<int, CString>)Runtime.LibraryGetExport(_libraryHandle, "sargs_value_at");
        _virtualTable.sargs_key_at = (delegate* unmanaged[Cdecl]<int, CString>)Runtime.LibraryGetExport(_libraryHandle, "sargs_key_at");
        _virtualTable.sargs_num_args = (delegate* unmanaged[Cdecl]<int>)Runtime.LibraryGetExport(_libraryHandle, "sargs_num_args");
        _virtualTable.sargs_find = (delegate* unmanaged[Cdecl]<CString, int>)Runtime.LibraryGetExport(_libraryHandle, "sargs_find");
        _virtualTable.sargs_boolean = (delegate* unmanaged[Cdecl]<CString, CBool>)Runtime.LibraryGetExport(_libraryHandle, "sargs_boolean");
        _virtualTable.sargs_equals = (delegate* unmanaged[Cdecl]<CString, CString, CBool>)Runtime.LibraryGetExport(_libraryHandle, "sargs_equals");
        _virtualTable.sargs_value_def = (delegate* unmanaged[Cdecl]<CString, CString, CString>)Runtime.LibraryGetExport(_libraryHandle, "sargs_value_def");
        _virtualTable.sargs_value = (delegate* unmanaged[Cdecl]<CString, CString>)Runtime.LibraryGetExport(_libraryHandle, "sargs_value");
        _virtualTable.sargs_exists = (delegate* unmanaged[Cdecl]<CString, CBool>)Runtime.LibraryGetExport(_libraryHandle, "sargs_exists");
        _virtualTable.sargs_isvalid = (delegate* unmanaged[Cdecl]<CBool>)Runtime.LibraryGetExport(_libraryHandle, "sargs_isvalid");
        _virtualTable.sargs_shutdown = (delegate* unmanaged[Cdecl]<void>)Runtime.LibraryGetExport(_libraryHandle, "sargs_shutdown");
        _virtualTable.sargs_setup = (delegate* unmanaged[Cdecl]<sargs_desc*, void>)Runtime.LibraryGetExport(_libraryHandle, "sargs_setup");

        #endregion

        #region "Variables"



        #endregion
    }

    private static void _UnloadVirtualTable()
    {
        #region "Functions"

        _virtualTable.sargs_value_at = (delegate* unmanaged[Cdecl]<int, CString>)IntPtr.Zero;
        _virtualTable.sargs_key_at = (delegate* unmanaged[Cdecl]<int, CString>)IntPtr.Zero;
        _virtualTable.sargs_num_args = (delegate* unmanaged[Cdecl]<int>)IntPtr.Zero;
        _virtualTable.sargs_find = (delegate* unmanaged[Cdecl]<CString, int>)IntPtr.Zero;
        _virtualTable.sargs_boolean = (delegate* unmanaged[Cdecl]<CString, CBool>)IntPtr.Zero;
        _virtualTable.sargs_equals = (delegate* unmanaged[Cdecl]<CString, CString, CBool>)IntPtr.Zero;
        _virtualTable.sargs_value_def = (delegate* unmanaged[Cdecl]<CString, CString, CString>)IntPtr.Zero;
        _virtualTable.sargs_value = (delegate* unmanaged[Cdecl]<CString, CString>)IntPtr.Zero;
        _virtualTable.sargs_exists = (delegate* unmanaged[Cdecl]<CString, CBool>)IntPtr.Zero;
        _virtualTable.sargs_isvalid = (delegate* unmanaged[Cdecl]<CBool>)IntPtr.Zero;
        _virtualTable.sargs_shutdown = (delegate* unmanaged[Cdecl]<void>)IntPtr.Zero;
        _virtualTable.sargs_setup = (delegate* unmanaged[Cdecl]<sargs_desc*, void>)IntPtr.Zero;

        #endregion

        #region "Variables"



        #endregion
    }

    // The virtual table represents a list of pointers to functions or variables which are resolved in a late manner.
    //	This allows for flexibility in swapping implementations at runtime.
    //	You can think of it in traditional OOP terms in C# as the locations of the virtual methods and/or properties of an object.
    public struct _VirtualTable
    {
        #region "Function Pointers"
        // These pointers hold the locations in the native library where functions are located at runtime.
        // See: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-9.0/function-pointers

        public delegate* unmanaged[Cdecl]<int, CString> sargs_value_at;
        public delegate* unmanaged[Cdecl]<int, CString> sargs_key_at;
        public delegate* unmanaged[Cdecl]<int> sargs_num_args;
        public delegate* unmanaged[Cdecl]<CString, int> sargs_find;
        public delegate* unmanaged[Cdecl]<CString, CBool> sargs_boolean;
        public delegate* unmanaged[Cdecl]<CString, CString, CBool> sargs_equals;
        public delegate* unmanaged[Cdecl]<CString, CString, CString> sargs_value_def;
        public delegate* unmanaged[Cdecl]<CString, CString> sargs_value;
        public delegate* unmanaged[Cdecl]<CString, CBool> sargs_exists;
        public delegate* unmanaged[Cdecl]<CBool> sargs_isvalid;
        public delegate* unmanaged[Cdecl]<void> sargs_shutdown;
        public delegate* unmanaged[Cdecl]<sargs_desc*, void> sargs_setup;

        #endregion

        #region "Variables"
        // These pointers hold the locations in the native library where global variables are located at runtime.
        //	The value pointed by these pointers are updated by reading/writing memory.



        #endregion
    }

    private static _VirtualTable _virtualTable;
}
